<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NAJ Task Manager</title>
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #4a90e2;
      --primary-hover: #357abd;
      --secondary: #5cb85c;
      --danger: #d9534f;
      --warning: #f0ad4e;
      --dark: #2c3e50;
      --darker: #1a252f;
      --light: #ecf0f1;
      --border: #bdc3c7;
      --shadow: rgba(0, 0, 0, 0.1);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f7fa;
      color: var(--dark);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Header */
    .header {
      background: white;
      border-bottom: 1px solid var(--border);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 4px var(--shadow);
    }

    .header h1 {
      font-size: 1.5rem;
      color: var(--dark);
      font-weight: 600;
    }

    .header-actions {
      display: flex;
      gap: 1rem;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background: var(--primary-hover);
    }

    .btn-secondary {
      background: white;
      color: var(--dark);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--light);
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background: #c9302c;
    }

    /* Main Layout */
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 250px;
      background: white;
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      box-shadow: 2px 0 4px var(--shadow);
    }

    .sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .project-list {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .project-item {
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .project-item:hover {
      background: var(--light);
    }

    .project-item.active {
      background: var(--primary);
      color: white;
    }

    .project-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .project-count {
      font-size: 12px;
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 6px;
      border-radius: 12px;
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      position: relative;
      overflow: auto;
      background: #f5f7fa;
    }

    .canvas {
      position: relative;
      width: 2000px;
      height: 2000px;
      background-image: 
        linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    /* Task Cards */
    .task-card {
      position: absolute;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow);
      min-width: 200px;
      max-width: 300px;
      cursor: move;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      user-select: none;
      border: 2px solid #4a90e2;
    }

    .task-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }

    .task-card.dragging {
      opacity: 0.8;
      cursor: grabbing;
      z-index: 1000;
    }

    .task-card.selected {
      box-shadow: 0 0 0 3px var(--primary);
    }

    .task-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--light);
      border-radius: 6px 6px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .task-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
    }

    .status-pending { background: var(--warning); }
    .status-progress { background: var(--primary); }
    .status-complete { background: var(--secondary); }

    .task-title {
      font-weight: 600;
      color: var(--dark);
      flex: 1;
    }

    .task-actions {
      display: flex;
      gap: 0.5rem;
    }

    .task-action {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--dark);
      padding: 0.25rem;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .task-action:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    .task-body {
      padding: 1rem;
    }

    .task-description {
      color: #666;
      font-size: 14px;
      margin-bottom: 1rem;
      line-height: 1.5;
    }

    .task-meta {
      display: flex;
      gap: 1rem;
      font-size: 12px;
      color: #999;
    }

    .task-subtasks {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .subtask {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0;
      font-size: 14px;
    }

    .subtask input[type="checkbox"] {
      cursor: pointer;
    }

    .subtask.completed label {
      text-decoration: line-through;
      color: #999;
    }

    /* Connection Lines */
    .connection {
      position: absolute;
      pointer-events: none;
      z-index: 1;
    }

    .connection-line {
      stroke: var(--primary);
      stroke-width: 2;
      fill: none;
      opacity: 0.6;
    }

    .connection-arrow {
      fill: var(--primary);
      opacity: 0.6;
    }

    /* Properties Panel */
    .properties-panel {
      width: 300px;
      background: white;
      border-left: 1px solid var(--border);
      padding: 1.5rem;
      overflow-y: auto;
      display: none;
    }

    .properties-panel.active {
      display: block;
    }

    .property-group {
      margin-bottom: 1.5rem;
    }

    .property-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }

    .property-input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
      transition: border-color 0.3s ease;
    }

    .property-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .property-textarea {
      min-height: 80px;
      resize: vertical;
    }

    .property-select {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
      background: white;
      cursor: pointer;
    }

    /* Modals */
    .modal {
      display: none;
      position: fixed;
      top: 0;
      left: 0;
      width: 100%;
      height: 100%;
      background: rgba(0, 0, 0, 0.5);
      z-index: 2000;
      align-items: center;
      justify-content: center;
    }

    .modal.active {
      display: flex;
    }

    .modal-content {
      background: white;
      border-radius: 8px;
      padding: 2rem;
      max-width: 500px;
      width: 90%;
      max-height: 80vh;
      overflow-y: auto;
      box-shadow: 0 4px 20px rgba(0, 0, 0, 0.15);
    }

    .modal-header {
      font-size: 1.25rem;
      font-weight: 600;
      margin-bottom: 1rem;
      color: var(--dark);
    }

    .modal-body {
      margin-bottom: 1.5rem;
    }

    .modal-footer {
      display: flex;
      justify-content: flex-end;
      gap: 1rem;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: white;
      border: 1px solid var(--border);
      border-radius: 4px;
      box-shadow: 0 2px 10px var(--shadow);
      display: none;
      z-index: 1500;
      min-width: 150px;
    }

    .context-menu.active {
      display: block;
    }

    .context-item {
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 14px;
    }

    .context-item:hover {
      background: var(--light);
    }

    .context-divider {
      height: 1px;
      background: var(--border);
      margin: 0.25rem 0;
    }

    /* Toolbar */
    .toolbar {
      background: white;
      border-bottom: 1px solid var(--border);
      padding: 0.5rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      box-shadow: 0 2px 4px var(--shadow);
    }

    .tool-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0 1rem;
      border-right: 1px solid var(--border);
    }

    .tool-group:last-child {
      border-right: none;
    }

    .tool-btn {
      background: none;
      border: 1px solid transparent;
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tool-btn:hover {
      background: var(--light);
    }

    .tool-btn.active {
      background: var(--primary);
      color: white;
    }

    /* Icons */
    .icon {
      width: 20px;
      height: 20px;
    }

    /* Notifications */
    .notification {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: var(--dark);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 3000;
    }

    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .sidebar {
        width: 200px;
      }
      
      .properties-panel {
        width: 250px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <h1>NAJ Task Manager</h1>
    <div class="header-actions">
      <button class="btn btn-secondary" onclick="taskManager.exportDiagram()">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <polyline points="9 9 9 15 12 12 15 15 15 9"></polyline>
        </svg>
        Export Diagram
      </button>
      <button class="btn btn-secondary" onclick="taskManager.exportList()">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="8" y1="6" x2="21" y2="6"></line>
          <line x1="8" y1="12" x2="21" y2="12"></line>
          <line x1="8" y1="18" x2="21" y2="18"></line>
          <line x1="3" y1="6" x2="3.01" y2="6"></line>
          <line x1="3" y1="12" x2="3.01" y2="12"></line>
          <line x1="3" y1="18" x2="3.01" y2="18"></line>
        </svg>
        Export List
      </button>
      <button class="btn btn-secondary" onclick="taskManager.clearAll()">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 6h18"></path>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        Clear All
      </button>
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="taskManager.zoomIn()" title="Zoom In">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
      <span id="zoomLevel" style="min-width: 50px; text-align: center;">100%</span>
      <button class="tool-btn" onclick="taskManager.zoomOut()" title="Zoom Out">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="taskManager.toggleGrid()" title="Toggle Grid">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="6" height="6"></rect>
          <rect x="9" y="3" width="6" height="6"></rect>
          <rect x="15" y="3" width="6" height="6"></rect>
          <rect x="3" y="9" width="6" height="6"></rect>
          <rect x="9" y="9" width="6" height="6"></rect>
          <rect x="15" y="9" width="6" height="6"></rect>
          <rect x="3" y="15" width="6" height="6"></rect>
          <rect x="9" y="15" width="6" height="6"></rect>
          <rect x="15" y="15" width="6" height="6"></rect>
        </svg>
      </button>
      <input type="color" id="bgColorPicker" value="#f5f7fa" title="Background Color" style="width: 40px; height: 32px; border: 1px solid var(--border); border-radius: 4px; cursor: pointer;" onchange="taskManager.changeBackgroundColor(this.value)">
    </div>
  </header>

  <!-- Toolbar -->
  <div class="toolbar">
    <div class="tool-group">
      <button class="tool-btn active" onclick="taskManager.setTool('select')" title="Select">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
        </svg>
      </button>
      <button class="tool-btn" onclick="taskManager.setTool('connect')" title="Connect Tasks">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="5" y1="12" x2="19" y2="12"></line>
          <polyline points="12 5 19 12 12 19"></polyline>
        </svg>
      </button>
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="taskManager.undo()" title="Undo">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="9 14 4 9 9 4"></polyline>
          <path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>
        </svg>
      </button>
      <button class="tool-btn" onclick="taskManager.redo()" title="Redo">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 14 20 9 15 4"></polyline>
          <path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>
        </svg>
      </button>
    </div>
    <div class="tool-group">
      <span>Project:</span>
      <select id="projectSelector" class="property-select" style="width: 200px;" onchange="taskManager.switchProject(this.value)">
        <option value="default">Default Project</option>
      </select>
      <button class="btn btn-primary" onclick="taskManager.createProject()">New Project</button>
    </div>
  </div>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <button class="btn btn-primary" style="width: 100%;" onclick="taskManager.createTask()">
          + Add Task
        </button>
      </div>
      <div class="project-list" id="taskList">
        <!-- Tasks will be listed here -->
      </div>
    </aside>

    <!-- Canvas Area -->
    <div class="canvas-area" id="canvasArea">
      <div class="canvas" id="canvas">
        <svg id="connectionSvg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
          <!-- Connections will be drawn here -->
        </svg>
        <!-- Task cards will be added here -->
      </div>
    </div>

    <!-- Properties Panel -->
    <aside class="properties-panel" id="propertiesPanel">
      <h3>Task Properties</h3>
      <div class="property-group">
        <label class="property-label">Title</label>
        <input type="text" class="property-input" id="taskTitleInput" placeholder="Task title">
      </div>
      <div class="property-group">
        <label class="property-label">Description</label>
        <textarea class="property-input property-textarea" id="taskDescInput" placeholder="Task description"></textarea>
      </div>
      <div class="property-group">
        <label class="property-label">Status</label>
        <select class="property-select" id="taskStatusInput">
          <option value="pending">Pending</option>
          <option value="progress">In Progress</option>
          <option value="complete">Complete</option>
        </select>
      </div>
      <div class="property-group">
        <label class="property-label">Due Date</label>
        <input type="date" class="property-input" id="taskDueInput">
      </div>
      <div class="property-group">
        <label class="property-label">Subtasks</label>
        <div id="subtasksList"></div>
        <button class="btn btn-secondary" style="margin-top: 0.5rem;" onclick="taskManager.addSubtask()">
          + Add Subtask
        </button>
      </div>
      <div class="property-group">
        <label class="property-label">Appearance</label>
        <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
          <div style="flex: 1;">
            <label style="font-size: 12px; color: #666;">Fill Color</label>
            <input type="color" class="property-input" id="taskFillColor" value="#ffffff" onchange="taskManager.updateTaskStyle('backgroundColor', this.value)">
          </div>
          <div style="flex: 1;">
            <label style="font-size: 12px; color: #666;">Border Color</label>
            <input type="color" class="property-input" id="taskBorderColor" value="#4a90e2" onchange="taskManager.updateTaskStyle('borderColor', this.value)">
          </div>
        </div>
        <div style="display: flex; gap: 0.5rem;">
          <div style="flex: 1;">
            <label style="font-size: 12px; color: #666;">Width</label>
            <input type="number" class="property-input" id="taskWidth" value="250" min="150" max="500" onchange="taskManager.updateTaskStyle('width', this.value + 'px')">
          </div>
          <div style="flex: 1;">
            <label style="font-size: 12px; color: #666;">Height</label>
            <select class="property-select" id="taskHeight" onchange="taskManager.updateTaskStyle('height', this.value)">
              <option value="auto">Auto</option>
              <option value="150px">Small</option>
              <option value="200px">Medium</option>
              <option value="300px">Large</option>
            </select>
          </div>
        </div>
      </div>
      <div class="property-group">
        <button class="btn btn-danger" onclick="taskManager.deleteSelectedTask()">Delete Task</button>
      </div>
    </aside>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-item" onclick="taskManager.contextAction('add')">Add Task</div>
    <div class="context-divider"></div>
    <div class="context-item" onclick="taskManager.contextAction('edit')">Edit Task</div>
    <div class="context-item" onclick="taskManager.contextAction('duplicate')">Duplicate</div>
    <div class="context-divider"></div>
    <div class="context-item" onclick="taskManager.contextAction('connect')">Connect To...</div>
    <div class="context-item" onclick="taskManager.contextAction('disconnect')">Remove Connections</div>
    <div class="context-divider"></div>
    <div class="context-item" onclick="taskManager.contextAction('delete')">Delete</div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <script>
    class TaskManager {
      constructor() {
        this.currentProject = 'default';
        this.projects = {
          default: {
            name: 'Default Project',
            tasks: {},
            connections: []
          }
        };
        this.selectedTask = null;
        this.currentTool = 'select';
        this.draggedTask = null;
        this.connectionStart = null;
        this.undoStack = [];
        this.redoStack = [];
        this.taskIdCounter = 0;
        this.zoom = 1;
        this.gridVisible = true;
        this.backgroundColor = '#f5f7fa';
        
        this.init();
      }

      init() {
        // Load saved data
        this.loadFromLocalStorage();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Render initial state
        this.renderTasks();
        this.updateProjectSelector();
        
        // Save state for undo
        this.saveState();
      }

      setupEventListeners() {
        const canvas = document.getElementById('canvas');
        const canvasArea = document.getElementById('canvasArea');
        
        // Canvas click events
        canvas.addEventListener('click', (e) => this.handleCanvasClick(e));
        canvas.addEventListener('contextmenu', (e) => this.handleContextMenu(e));
        
        // Mouse wheel zoom
        canvasArea.addEventListener('wheel', (e) => {
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            this.setZoom(this.zoom + delta);
          }
        });
        
        // Property inputs
        document.getElementById('taskTitleInput').addEventListener('input', (e) => this.updateTaskProperty('title', e.target.value));
        document.getElementById('taskDescInput').addEventListener('input', (e) => this.updateTaskProperty('description', e.target.value));
        document.getElementById('taskStatusInput').addEventListener('change', (e) => this.updateTaskProperty('status', e.target.value));
        document.getElementById('taskDueInput').addEventListener('change', (e) => this.updateTaskProperty('dueDate', e.target.value));
        
        // Hide context menu on click
        document.addEventListener('click', () => {
          document.getElementById('contextMenu').classList.remove('active');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.ctrlKey || e.metaKey) {
            switch(e.key) {
              case 'z':
                e.preventDefault();
                this.undo();
                break;
              case 'y':
                e.preventDefault();
                this.redo();
                break;
              case 's':
                e.preventDefault();
                this.saveToLocalStorage();
                this.showNotification('Project saved');
                break;
              case '=':
              case '+':
                e.preventDefault();
                this.zoomIn();
                break;
              case '-':
                e.preventDefault();
                this.zoomOut();
                break;
            }
          } else if (e.key === 'Delete' && this.selectedTask) {
            this.deleteSelectedTask();
          }
        });
      }

      handleCanvasClick(e) {
        if (e.target.id === 'canvas') {
          this.selectTask(null);
        }
      }

      handleContextMenu(e) {
        e.preventDefault();
        const taskCard = e.target.closest('.task-card');
        if (taskCard) {
          this.showContextMenu(e.clientX, e.clientY, taskCard.dataset.taskId);
        } else if (e.target.id === 'canvas') {
          // Show context menu for canvas
          this.showCanvasContextMenu(e.clientX, e.clientY, e);
        }
      }

      showCanvasContextMenu(x, y, e) {
        const menu = document.getElementById('contextMenu');
        menu.innerHTML = `
          <div class="context-item" onclick="taskManager.contextAction('add')">Add Task Here</div>
          <div class="context-divider"></div>
          <div class="context-item" onclick="taskManager.toggleGrid()">Toggle Grid</div>
          <div class="context-item" onclick="taskManager.promptBackgroundColor()">Change Background Color</div>
        `;
        
        const rect = e.target.getBoundingClientRect();
        const canvasX = (e.clientX - rect.left + e.target.parentElement.scrollLeft) / this.zoom;
        const canvasY = (e.clientY - rect.top + e.target.parentElement.scrollTop) / this.zoom;
        
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('active');
        menu.dataset.canvasX = canvasX;
        menu.dataset.canvasY = canvasY;
        menu.dataset.isCanvas = 'true';
      }

      showContextMenu(x, y, taskId) {
        const menu = document.getElementById('contextMenu');
        menu.innerHTML = `
          <div class="context-item" onclick="taskManager.contextAction('edit')">Edit Task</div>
          <div class="context-item" onclick="taskManager.contextAction('duplicate')">Duplicate</div>
          <div class="context-divider"></div>
          <div class="context-item" onclick="taskManager.contextAction('connect')">Connect To...</div>
          <div class="context-item" onclick="taskManager.contextAction('disconnect')">Remove Connections</div>
          <div class="context-divider"></div>
          <div class="context-item" onclick="taskManager.contextAction('delete')">Delete</div>
        `;
        
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('active');
        menu.dataset.taskId = taskId;
        menu.dataset.isCanvas = 'false';
      }

      contextAction(action) {
        const menu = document.getElementById('contextMenu');
        const isCanvas = menu.dataset.isCanvas === 'true';
        
        if (isCanvas && action === 'add') {
          const x = parseFloat(menu.dataset.canvasX);
          const y = parseFloat(menu.dataset.canvasY);
          this.createTask(x, y);
        } else {
          const taskId = menu.dataset.taskId;
          
          switch(action) {
            case 'edit':
              this.selectTask(taskId);
              break;
            case 'duplicate':
              this.duplicateTask(taskId);
              break;
            case 'delete':
              this.deleteTask(taskId);
              break;
            case 'connect':
              this.startConnection(taskId);
              break;
            case 'disconnect':
              this.removeConnections(taskId);
              break;
          }
        }
        
        menu.classList.remove('active');
      }

      createTask(x, y) {
        const taskId = `task_${++this.taskIdCounter}`;
        const task = {
          id: taskId,
          title: 'New Task',
          description: 'Click to edit description',
          status: 'pending',
          x: x || 100,
          y: y || 100,
          subtasks: [],
          createdAt: new Date().toISOString(),
          dueDate: null,
          style: {
            backgroundColor: '#ffffff',
            borderColor: '#4a90e2',
            width: '250px',
            height: 'auto'
          }
        };
        
        this.projects[this.currentProject].tasks[taskId] = task;
        this.renderTask(task);
        this.selectTask(taskId);
        this.saveState();
        this.saveToLocalStorage();
        this.showNotification('Task created');
      }

      renderTask(task) {
        const canvas = document.getElementById('canvas');
        const taskCard = document.createElement('div');
        taskCard.className = 'task-card';
        taskCard.dataset.taskId = task.id;
        taskCard.style.left = `${task.x}px`;
        taskCard.style.top = `${task.y}px`;
        
        // Apply saved styles
        if (task.style) {
          taskCard.style.backgroundColor = task.style.backgroundColor || '#ffffff';
          taskCard.style.borderColor = task.style.borderColor || '#4a90e2';
          taskCard.style.width = task.style.width || '250px';
          if (task.style.height !== 'auto') {
            taskCard.style.height = task.style.height;
          }
        }
        
        taskCard.innerHTML = `
          <div class="task-header">
            <div style="display: flex; align-items: center;">
              <span class="task-status status-${task.status}"></span>
              <span class="task-title">${task.title}</span>
            </div>
            <div class="task-actions">
              <button class="task-action" onclick="taskManager.toggleTaskExpand('${task.id}')">
                <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                  <path d="M6 9l6 6 6-6"/>
                </svg>
              </button>
            </div>
          </div>
          <div class="task-body">
            <p class="task-description">${task.description}</p>
            <div class="task-meta">
              ${task.dueDate ? `<span>Due: ${new Date(task.dueDate).toLocaleDateString()}</span>` : ''}
              ${task.subtasks.length > 0 ? `<span>${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks</span>` : ''}
            </div>
            ${task.subtasks.length > 0 ? `
              <div class="task-subtasks">
                ${task.subtasks.map((subtask, index) => `
                  <div class="subtask ${subtask.completed ? 'completed' : ''}">
                    <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
                      onchange="taskManager.toggleSubtask('${task.id}', ${index})">
                    <label>${subtask.text}</label>
                  </div>
                `).join('')}
              </div>
            ` : ''}
          </div>
        `;
        
        canvas.appendChild(taskCard);
        this.makeDraggable(taskCard);
        
        // Update sidebar
        this.updateTaskList();
      }

      makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialX, initialY;
        
        const taskHeader = element.querySelector('.task-header');
        
        taskHeader.addEventListener('mousedown', (e) => {
          if (e.target.closest('.task-action')) return;
          
          isDragging = true;
          element.classList.add('dragging');
          
          startX = e.clientX;
          startY = e.clientY;
          initialX = element.offsetLeft;
          initialY = element.offsetTop;
          
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          
          element.style.left = `${initialX + dx}px`;
          element.style.top = `${initialY + dy}px`;
          
          // Update connections
          this.updateConnections();
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            
            // Update task position in data
            const taskId = element.dataset.taskId;
            const task = this.projects[this.currentProject].tasks[taskId];
            if (task) {
              task.x = element.offsetLeft;
              task.y = element.offsetTop;
              this.saveToLocalStorage();
              this.saveState();
            }
          }
        });
        
        // Click to select
        element.addEventListener('click', (e) => {
          if (!e.target.closest('.task-action')) {
            this.selectTask(element.dataset.taskId);
          }
        });
      }

      selectTask(taskId) {
        // Remove previous selection
        document.querySelectorAll('.task-card').forEach(card => {
          card.classList.remove('selected');
        });
        
        if (taskId) {
          const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
          if (taskCard) {
            taskCard.classList.add('selected');
            this.selectedTask = taskId;
            this.showProperties(taskId);
          }
        } else {
          this.selectedTask = null;
          this.hideProperties();
        }
        
        // Handle connection tool
        if (this.currentTool === 'connect' && taskId && this.connectionStart && this.connectionStart !== taskId) {
          this.createConnection(this.connectionStart, taskId);
          this.connectionStart = null;
          this.setTool('select');
        } else if (this.currentTool === 'connect' && taskId) {
          this.connectionStart = taskId;
        }
      }

      showProperties(taskId) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (!task) return;
        
        const panel = document.getElementById('propertiesPanel');
        panel.classList.add('active');
        
        document.getElementById('taskTitleInput').value = task.title;
        document.getElementById('taskDescInput').value = task.description;
        document.getElementById('taskStatusInput').value = task.status;
        document.getElementById('taskDueInput').value = task.dueDate || '';
        
        // Set appearance values
        if (task.style) {
          document.getElementById('taskFillColor').value = task.style.backgroundColor || '#ffffff';
          document.getElementById('taskBorderColor').value = task.style.borderColor || '#4a90e2';
          document.getElementById('taskWidth').value = parseInt(task.style.width) || 250;
          document.getElementById('taskHeight').value = task.style.height || 'auto';
        }
        
        // Render subtasks
        this.renderSubtasks(task);
      }

      hideProperties() {
        document.getElementById('propertiesPanel').classList.remove('active');
      }

      updateTaskProperty(property, value) {
        if (!this.selectedTask) return;
        
        const task = this.projects[this.currentProject].tasks[this.selectedTask];
        if (task) {
          task[property] = value;
          this.renderTasks();
          this.saveToLocalStorage();
          this.saveState();
        }
      }

      renderSubtasks(task) {
        const container = document.getElementById('subtasksList');
        container.innerHTML = task.subtasks.map((subtask, index) => `
          <div class="subtask ${subtask.completed ? 'completed' : ''}">
            <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
              onchange="taskManager.toggleSubtask('${task.id}', ${index})">
            <input type="text" class="property-input" value="${subtask.text}" 
              onchange="taskManager.updateSubtask('${task.id}', ${index}, this.value)"
              style="flex: 1; margin-left: 0.5rem;">
            <button class="task-action" onclick="taskManager.removeSubtask('${task.id}', ${index})">
              <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        `).join('');
      }

      addSubtask() {
        if (!this.selectedTask) return;
        
        const task = this.projects[this.currentProject].tasks[this.selectedTask];
        if (task) {
          task.subtasks.push({
            text: 'New subtask',
            completed: false
          });
          this.renderSubtasks(task);
          this.renderTasks();
          this.saveToLocalStorage();
          this.saveState();
        }
      }

      toggleSubtask(taskId, index) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (task && task.subtasks[index]) {
          task.subtasks[index].completed = !task.subtasks[index].completed;
          this.renderTasks();
          this.saveToLocalStorage();
          this.saveState();
        }
      }

      updateSubtask(taskId, index, text) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (task && task.subtasks[index]) {
          task.subtasks[index].text = text;
          this.saveToLocalStorage();
          this.saveState();
        }
      }

      removeSubtask(taskId, index) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (task) {
          task.subtasks.splice(index, 1);
          this.renderSubtasks(task);
          this.renderTasks();
          this.saveToLocalStorage();
          this.saveState();
        }
      }

      deleteSelectedTask() {
        if (this.selectedTask) {
          this.deleteTask(this.selectedTask);
        }
      }

      deleteTask(taskId) {
        if (confirm('Are you sure you want to delete this task?')) {
          // Remove connections
          this.removeConnections(taskId);
          
          // Remove task
          delete this.projects[this.currentProject].tasks[taskId];
          
          // Update UI
          this.renderTasks();
          this.hideProperties();
          this.selectedTask = null;
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Task deleted');
        }
      }

      duplicateTask(taskId) {
        const originalTask = this.projects[this.currentProject].tasks[taskId];
        if (originalTask) {
          const newTask = {
            ...originalTask,
            id: `task_${++this.taskIdCounter}`,
            title: `${originalTask.title} (Copy)`,
            x: originalTask.x + 50,
            y: originalTask.y + 50,
            subtasks: originalTask.subtasks.map(s => ({...s})),
            style: originalTask.style ? {...originalTask.style} : {
              backgroundColor: '#ffffff',
              borderColor: '#4a90e2',
              width: '250px',
              height: 'auto'
            }
          };
          
          this.projects[this.currentProject].tasks[newTask.id] = newTask;
          this.renderTask(newTask);
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Task duplicated');
        }
      }

      createConnection(fromId, toId) {
        const connections = this.projects[this.currentProject].connections;
        
        // Check if connection already exists
        const exists = connections.some(c => 
          (c.from === fromId && c.to === toId) || 
          (c.from === toId && c.to === fromId)
        );
        
        if (!exists) {
          connections.push({ from: fromId, to: toId });
          this.renderConnections();
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Tasks connected');
        }
      }

      removeConnections(taskId) {
        const connections = this.projects[this.currentProject].connections;
        this.projects[this.currentProject].connections = connections.filter(c => 
          c.from !== taskId && c.to !== taskId
        );
        this.renderConnections();
        this.saveToLocalStorage();
        this.saveState();
      }

      renderConnections() {
        const svg = document.getElementById('connectionSvg');
        svg.innerHTML = '';
        
        this.projects[this.currentProject].connections.forEach(conn => {
          const fromCard = document.querySelector(`[data-task-id="${conn.from}"]`);
          const toCard = document.querySelector(`[data-task-id="${conn.to}"]`);
          
          if (fromCard && toCard) {
            const fromRect = fromCard.getBoundingClientRect();
            const toRect = toCard.getBoundingClientRect();
            const canvasRect = svg.getBoundingClientRect();
            
            const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
            const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
            const y2 = toRect.top + toRect.height / 2 - canvasRect.top;
            
            // Create curved path
            const dx = x2 - x1;
            const dy = y2 - y1;
            const cx = x1 + dx / 2;
            const cy = y1 + dy / 2 - Math.abs(dx) * 0.2;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`);
            path.setAttribute('class', 'connection-line');
            
            // Add arrow
            const angle = Math.atan2(y2 - cy, x2 - cx);
            const arrowSize = 10;
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrow.setAttribute('points', `
              ${x2},${y2} 
              ${x2 - arrowSize * Math.cos(angle - Math.PI / 6)},${y2 - arrowSize * Math.sin(angle - Math.PI / 6)} 
              ${x2 - arrowSize * Math.cos(angle + Math.PI / 6)},${y2 - arrowSize * Math.sin(angle + Math.PI / 6)}
            `);
            arrow.setAttribute('class', 'connection-arrow');
            
            svg.appendChild(path);
            svg.appendChild(arrow);
          }
        });
      }

      updateConnections() {
        // Re-render connections when tasks move
        this.renderConnections();
      }

      renderTasks() {
        const canvas = document.getElementById('canvas');
        const taskCards = canvas.querySelectorAll('.task-card');
        taskCards.forEach(card => card.remove());
        
        Object.values(this.projects[this.currentProject].tasks).forEach(task => {
          this.renderTask(task);
        });
        
        this.renderConnections();
        this.updateTaskList();
      }

      updateTaskList() {
        const taskList = document.getElementById('taskList');
        const tasks = Object.values(this.projects[this.currentProject].tasks);
        
        taskList.innerHTML = tasks.map(task => `
          <div class="project-item" onclick="taskManager.selectTask('${task.id}')">
            <span class="task-status status-${task.status}"></span>
            <span class="project-name">${task.title}</span>
            <span class="project-count">${task.status}</span>
          </div>
        `).join('');
      }

      setTool(tool) {
        this.currentTool = tool;
        this.connectionStart = null;
        
        // Update UI
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        event.target.closest('.tool-btn').classList.add('active');
        
        // Update cursor
        const canvas = document.getElementById('canvas');
        if (tool === 'connect') {
          canvas.style.cursor = 'crosshair';
        } else {
          canvas.style.cursor = 'default';
        }
      }

      updateTaskStyle(property, value) {
        if (!this.selectedTask) return;
        
        const task = this.projects[this.currentProject].tasks[this.selectedTask];
        if (task) {
          if (!task.style) {
            task.style = {
              backgroundColor: '#ffffff',
              borderColor: '#4a90e2',
              width: '250px',
              height: 'auto'
            };
          }
          
          task.style[property] = value;
          
          // Apply style to the element
          const taskCard = document.querySelector(`[data-task-id="${this.selectedTask}"]`);
          if (taskCard) {
            taskCard.style[property] = value;
          }
          
          this.saveToLocalStorage();
          this.saveState();
        }
      }

      zoomIn() {
        this.setZoom(Math.min(this.zoom + 0.1, 2));
      }

      zoomOut() {
        this.setZoom(Math.max(this.zoom - 0.1, 0.3));
      }

      setZoom(newZoom) {
        this.zoom = newZoom;
        const canvas = document.getElementById('canvas');
        canvas.style.transform = `scale(${this.zoom})`;
        canvas.style.transformOrigin = '0 0';
        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
        this.updateConnections();
      }

      toggleGrid() {
        this.gridVisible = !this.gridVisible;
        const canvas = document.getElementById('canvas');
        if (this.gridVisible) {
          canvas.style.backgroundImage = 
            'linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px), ' +
            'linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px)';
        } else {
          canvas.style.backgroundImage = 'none';
        }
        this.saveToLocalStorage();
      }

      changeBackgroundColor(color) {
        this.backgroundColor = color;
        const canvas = document.getElementById('canvas');
        const canvasArea = document.getElementById('canvasArea');
        canvas.style.backgroundColor = color;
        canvasArea.style.backgroundColor = color;
        this.saveToLocalStorage();
      }

      promptBackgroundColor() {
        const color = prompt('Enter background color (hex code):', this.backgroundColor);
        if (color) {
          this.changeBackgroundColor(color);
          document.getElementById('bgColorPicker').value = color;
        }
      }

      createProject() {
        const name = prompt('Enter project name:');
        if (name) {
          const projectId = `project_${Date.now()}`;
          this.projects[projectId] = {
            name: name,
            tasks: {},
            connections: []
          };
          this.switchProject(projectId);
          this.updateProjectSelector();
          this.saveToLocalStorage();
          this.showNotification('Project created');
        }
      }

      switchProject(projectId) {
        this.currentProject = projectId;
        this.selectedTask = null;
        this.renderTasks();
        this.hideProperties();
        this.saveState();
      }

      updateProjectSelector() {
        const selector = document.getElementById('projectSelector');
        selector.innerHTML = Object.entries(this.projects).map(([id, project]) => `
          <option value="${id}" ${id === this.currentProject ? 'selected' : ''}>${project.name}</option>
        `).join('');
      }

      saveState() {
        const state = {
          currentProject: this.currentProject,
          projects: JSON.parse(JSON.stringify(this.projects))
        };
        this.undoStack.push(state);
        if (this.undoStack.length > 50) this.undoStack.shift();
        this.redoStack = [];
      }

      undo() {
        if (this.undoStack.length > 1) {
          this.redoStack.push(this.undoStack.pop());
          const state = this.undoStack[this.undoStack.length - 1];
          this.restoreState(state);
          this.showNotification('Undo');
        }
      }

      redo() {
        if (this.redoStack.length > 0) {
          const state = this.redoStack.pop();
          this.undoStack.push(state);
          this.restoreState(state);
          this.showNotification('Redo');
        }
      }

      restoreState(state) {
        this.projects = JSON.parse(JSON.stringify(state.projects));
        this.currentProject = state.currentProject;
        this.renderTasks();
        this.updateProjectSelector();
        this.saveToLocalStorage();
      }

      saveToLocalStorage() {
        const data = {
          projects: this.projects,
          currentProject: this.currentProject,
          taskIdCounter: this.taskIdCounter,
          zoom: this.zoom,
          gridVisible: this.gridVisible,
          backgroundColor: this.backgroundColor
        };
        localStorage.setItem('najTaskManager', JSON.stringify(data));
      }

      loadFromLocalStorage() {
        const saved = localStorage.getItem('najTaskManager');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            this.projects = data.projects || this.projects;
            this.currentProject = data.currentProject || this.currentProject;
            this.taskIdCounter = data.taskIdCounter || 0;
            this.zoom = data.zoom || 1;
            this.gridVisible = data.gridVisible !== undefined ? data.gridVisible : true;
            this.backgroundColor = data.backgroundColor || '#f5f7fa';
            
            // Apply saved settings
            this.setZoom(this.zoom);
            this.changeBackgroundColor(this.backgroundColor);
            if (!this.gridVisible) {
              this.toggleGrid();
            }
          } catch (e) {
            console.error('Failed to load saved data:', e);
          }
        }
      }

      clearAll() {
        if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
          localStorage.removeItem('najTaskManager');
          location.reload();
        }
      }

      exportList() {
        // Create a simple HTML representation for printing as list
        const printWindow = window.open('', '_blank');
        const project = this.projects[this.currentProject];
        const tasks = Object.values(project.tasks);
        
        // Sort tasks by status
        const sortedTasks = tasks.sort((a, b) => {
          const statusOrder = { 'complete': 3, 'progress': 2, 'pending': 1 };
          return statusOrder[a.status] - statusOrder[b.status];
        });
        
        const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>${project.name} - Task List</title>
            <style>
              body { 
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
                padding: 20px;
                line-height: 1.6;
              }
              h1 { 
                color: #2c3e50; 
                border-bottom: 2px solid #3498db;
                padding-bottom: 10px;
              }
              .meta {
                color: #666;
                font-size: 14px;
                margin-bottom: 20px;
              }
              .task { 
                margin-bottom: 25px; 
                padding: 15px; 
                border: 1px solid #ddd; 
                border-radius: 8px;
                page-break-inside: avoid;
              }
              .task-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
              }
              .task-title { 
                font-weight: bold; 
                font-size: 18px; 
                color: #2c3e50;
              }
              .task-meta { 
                color: #666; 
                font-size: 12px; 
                margin-bottom: 10px; 
              }
              .task-description {
                margin-bottom: 10px;
                color: #444;
              }
              .subtask { 
                margin-left: 20px; 
                padding: 5px 0; 
              }
              .subtask-header {
                font-weight: 600;
                margin-top: 10px;
                margin-bottom: 5px;
              }
              .completed { 
                text-decoration: line-through; 
                color: #999; 
              }
              .status { 
                display: inline-block; 
                padding: 4px 12px; 
                border-radius: 20px; 
                font-size: 12px; 
                font-weight: 600;
                text-transform: uppercase;
              }
              .status-pending { 
                background: #fff3cd; 
                color: #856404; 
              }
              .status-progress { 
                background: #cce5ff; 
                color: #004085; 
              }
              .status-complete { 
                background: #d4edda; 
                color: #155724; 
              }
              .connections {
                margin-top: 10px;
                font-size: 12px;
                color: #666;
              }
              @media print {
                body { padding: 10px; }
                .task { break-inside: avoid; }
              }
            </style>
          </head>
          <body>
            <h1>${project.name} - Task List</h1>
            <div class="meta">
              <strong>Generated:</strong> ${new Date().toLocaleString()}<br>
              <strong>Total Tasks:</strong> ${tasks.length} 
              (${tasks.filter(t => t.status === 'complete').length} completed, 
              ${tasks.filter(t => t.status === 'progress').length} in progress, 
              ${tasks.filter(t => t.status === 'pending').length} pending)
            </div>
            
            ${sortedTasks.map(task => {
              const connections = project.connections.filter(c => c.from === task.id || c.to === task.id);
              const connectedTasks = connections.map(c => {
                const connectedId = c.from === task.id ? c.to : c.from;
                const connectedTask = project.tasks[connectedId];
                return connectedTask ? connectedTask.title : 'Unknown';
              });
              
              return `
              <div class="task">
                <div class="task-header">
                  <div class="task-title">${task.title}</div>
                  <span class="status status-${task.status}">${task.status}</span>
                </div>
                <div class="task-meta">
                  Created: ${new Date(task.createdAt).toLocaleDateString()}
                  ${task.dueDate ? ` | Due: ${new Date(task.dueDate).toLocaleDateString()}` : ''}
                </div>
                <div class="task-description">${task.description}</div>
                ${task.subtasks.length > 0 ? `
                  <div class="subtask-header">Subtasks (${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} completed):</div>
                  ${task.subtasks.map(subtask => `
                    <div class="subtask ${subtask.completed ? 'completed' : ''}">
                      ${subtask.completed ? '☑' : '☐'} ${subtask.text}
                    </div>
                  `).join('')}
                ` : ''}
                ${connectedTasks.length > 0 ? `
                  <div class="connections">
                    <strong>Connected to:</strong> ${connectedTasks.join(', ')}
                  </div>
                ` : ''}
              </div>
            `}).join('')}
          </body>
          </html>
        `;
        
        printWindow.document.write(html);
        printWindow.document.close();
        
        setTimeout(() => {
          printWindow.print();
        }, 250);
        
        this.showNotification('List view ready - use print dialog to save as PDF');
      }

      exportDiagram() {
        // Create a visual representation of the diagram
        const printWindow = window.open('', '_blank');
        const project = this.projects[this.currentProject];
        const tasks = Object.values(project.tasks);
        
        // Find canvas bounds
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        tasks.forEach(task => {
          minX = Math.min(minX, task.x);
          minY = Math.min(minY, task.y);
          maxX = Math.max(maxX, task.x + 300); // Approximate width
          maxY = Math.max(maxY, task.y + 200); // Approximate height
        });
        
        const width = Math.max(maxX - minX + 100, 800);
        const height = Math.max(maxY - minY + 100, 600);
        
        const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>${project.name} - Task Diagram</title>
            <style>
              @page {
                size: landscape;
                margin: 10mm;
              }
              body { 
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
                margin: 0;
                padding: 20px;
              }
              h1 { 
                color: #2c3e50; 
                font-size: 24px;
                margin-bottom: 10px;
              }
              .meta {
                color: #666;
                font-size: 12px;
                margin-bottom: 20px;
              }
              .diagram-container {
                position: relative;
                width: ${width}px;
                height: ${height}px;
                border: 1px solid #ddd;
                background: ${this.backgroundColor};
                ${this.gridVisible ? `
                  background-image: 
                    linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
                  background-size: 20px 20px;
                ` : ''}
              }
              .task-box {
                position: absolute;
                background: white;
                border: 2px solid #4a90e2;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                min-width: 200px;
                max-width: 300px;
                font-size: 12px;
              }
              .task-header {
                padding: 8px;
                background: #f8f9fa;
                border-bottom: 1px solid #dee2e6;
                border-radius: 6px 6px 0 0;
                font-weight: bold;
              }
              .task-content {
                padding: 8px;
              }
              .task-description {
                color: #666;
                margin-bottom: 5px;
              }
              .task-meta {
                font-size: 10px;
                color: #999;
              }
              .status-indicator {
                display: inline-block;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                margin-right: 5px;
              }
              .status-pending { background: #ffc107; }
              .status-progress { background: #007bff; }
              .status-complete { background: #28a745; }
              svg {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
              }
              .connection-line {
                stroke: #4a90e2;
                stroke-width: 2;
                fill: none;
                opacity: 0.6;
              }
              @media print {
                body { padding: 0; }
                h1 { font-size: 18px; }
                .diagram-container { 
                  max-width: 100%; 
                  overflow: visible;
                  page-break-inside: avoid;
                }
              }
            </style>
          </head>
          <body>
            <h1>${project.name}</h1>
            <div class="meta">Generated: ${new Date().toLocaleString()}</div>
            
            <div class="diagram-container">
              <svg>
                ${project.connections.map(conn => {
                  const fromTask = project.tasks[conn.from];
                  const toTask = project.tasks[conn.to];
                  if (!fromTask || !toTask) return '';
                  
                  const x1 = fromTask.x - minX + 125;
                  const y1 = fromTask.y - minY + 50;
                  const x2 = toTask.x - minX + 125;
                  const y2 = toTask.y - minY + 50;
                  
                  const dx = x2 - x1;
                  const dy = y2 - y1;
                  const cx = x1 + dx / 2;
                  const cy = y1 + dy / 2 - Math.abs(dx) * 0.2;
                  
                  return `<path d="M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}" class="connection-line"/>`;
                }).join('')}
              </svg>
              
              ${tasks.map(task => `
                <div class="task-box" style="
                  left: ${task.x - minX}px; 
                  top: ${task.y - minY}px;
                  ${task.style ? `
                    background-color: ${task.style.backgroundColor || '#ffffff'};
                    border-color: ${task.style.borderColor || '#4a90e2'};
                    width: ${task.style.width || '250px'};
                  ` : ''}
                ">
                  <div class="task-header">
                    <span class="status-indicator status-${task.status}"></span>
                    ${task.title}
                  </div>
                  <div class="task-content">
                    <div class="task-description">${task.description}</div>
                    <div class="task-meta">
                      ${task.dueDate ? `Due: ${new Date(task.dueDate).toLocaleDateString()}` : ''}
                      ${task.subtasks.length > 0 ? ` | ${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks` : ''}
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          </body>
          </html>
        `;
        
        printWindow.document.write(html);
        printWindow.document.close();
        
        setTimeout(() => {
          printWindow.print();
        }, 250);
        
        this.showNotification('Diagram ready - use print dialog to save as PDF');
      }

      exportPDF() {
        this.exportList();
      }

      showNotification(message) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.classList.add('show');
        
        setTimeout(() => {
          notification.classList.remove('show');
        }, 3000);
      }

      // Additional utility methods
      toggleTaskExpand(taskId) {
        // This could be expanded to show/hide task details
        const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
        if (taskCard) {
          const body = taskCard.querySelector('.task-body');
          body.style.display = body.style.display === 'none' ? 'block' : 'none';
        }
      }
    }

    // Initialize the task manager
    const taskManager = new TaskManager();
  </script>
</body>
</html>
