<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>NAJ Task Manager</title>
  
  <!-- Browser Icon -->
  <link rel="icon" href="https://i.imgur.com/vksyj5W.png" type="image/png">
  
  <!-- For Apple devices -->
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="apple-mobile-web-app-title" content="NAJ Developments">
  <link rel="apple-touch-icon" href="https://i.imgur.com/vksyj5W.png">
  
  <!-- For Android -->
  <meta name="mobile-web-app-capable" content="yes">
  <link rel="manifest" href='data:application/manifest+json,{"name":"NAJ Developments","short_name":"NAJ","icons":[{"src":"https://i.imgur.com/vksyj5W.png","sizes":"192x192","type":"image/png"}],"start_url":"/","display":"standalone"}'>
  
  <style>
    * {
      margin: 0;
      padding: 0;
      box-sizing: border-box;
    }

    :root {
      --primary: #4a90e2;
      --primary-hover: #357abd;
      --secondary: #5cb85c;
      --danger: #d9534f;
      --warning: #f0ad4e;
      --dark: #2c3e50;
      --darker: #1a252f;
      --light: #ecf0f1;
      --border: #bdc3c7;
      --shadow: rgba(0, 0, 0, 0.1);
    }

    body {
      font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
      background: #f5f7fa;
      color: var(--dark);
      height: 100vh;
      display: flex;
      flex-direction: column;
      overflow: hidden;
    }

    /* Header */
    .header {
      background: white;
      border-bottom: 1px solid var(--border);
      padding: 1rem 2rem;
      display: flex;
      justify-content: space-between;
      align-items: center;
      box-shadow: 0 2px 4px var(--shadow);
    }

    .header h1 {
      font-size: 1.5rem;
      color: var(--dark);
      font-weight: 600;
    }

    .header-actions {
      display: flex;
      gap: 1rem;
    }

    .btn {
      padding: 0.5rem 1rem;
      border: none;
      border-radius: 4px;
      cursor: pointer;
      font-size: 14px;
      transition: all 0.3s ease;
      display: inline-flex;
      align-items: center;
      gap: 0.5rem;
    }

    .btn-primary {
      background: var(--primary);
      color: white;
    }

    .btn-primary:hover {
      background: var(--primary-hover);
    }

    .btn-secondary {
      background: white;
      color: var(--dark);
      border: 1px solid var(--border);
    }

    .btn-secondary:hover {
      background: var(--light);
    }

    .btn-danger {
      background: var(--danger);
      color: white;
    }

    .btn-danger:hover {
      background: #c9302c;
    }

    /* Main Layout */
    .main-container {
      display: flex;
      flex: 1;
      overflow: hidden;
    }

    /* Sidebar */
    .sidebar {
      width: 250px;
      background: white;
      border-right: 1px solid var(--border);
      display: flex;
      flex-direction: column;
      box-shadow: 2px 0 4px var(--shadow);
    }

    .sidebar-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
    }

    .project-list {
      flex: 1;
      overflow-y: auto;
      padding: 1rem;
    }

    .project-item {
      padding: 0.75rem;
      margin-bottom: 0.5rem;
      border-radius: 4px;
      cursor: pointer;
      transition: all 0.3s ease;
      display: flex;
      justify-content: space-between;
      align-items: center;
    }

    .project-item:hover {
      background: var(--light);
    }

    .project-item.active {
      background: var(--primary);
      color: white;
    }

    .project-name {
      flex: 1;
      white-space: nowrap;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .project-count {
      font-size: 12px;
      background: rgba(0, 0, 0, 0.1);
      padding: 2px 6px;
      border-radius: 12px;
    }

    /* Canvas Area */
    .canvas-area {
      flex: 1;
      position: relative;
      overflow: auto;
      background: #f5f7fa;
      background-image: 
        linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
        linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
      background-size: 20px 20px;
    }

    .canvas {
      position: relative;
      width: 2000px;
      height: 2000px;
    }

    /* Task Cards */
    .task-card {
      position: absolute;
      background: white;
      border-radius: 8px;
      box-shadow: 0 2px 8px var(--shadow);
      min-width: 200px;
      min-height: 100px;
      cursor: move;
      transition: transform 0.2s ease, box-shadow 0.2s ease;
      user-select: none;
      border: 2px solid #4a90e2;
      resize: both;
      overflow: hidden;
      z-index: 10;
      display: flex;
      flex-direction: column;
      box-sizing: border-box;
    }
    
    /* Add a visual resize handle */
    .task-card::after {
      content: '';
      position: absolute;
      bottom: 0;
      right: 0;
      width: 20px;
      height: 20px;
      background: linear-gradient(135deg, transparent 50%, #ccc 50%);
      cursor: se-resize;
      border-bottom-right-radius: 6px;
    }

    .task-card:hover {
      box-shadow: 0 4px 16px rgba(0, 0, 0, 0.15);
    }

    .task-card.dragging {
      opacity: 0.8;
      cursor: grabbing;
      z-index: 1000;
    }

    .task-card.selected {
      box-shadow: 0 0 0 3px var(--primary);
      z-index: 100;
    }

    .task-header {
      padding: 1rem;
      border-bottom: 1px solid var(--border);
      background: var(--light);
      border-radius: 6px 6px 0 0;
      display: flex;
      justify-content: space-between;
      align-items: center;
      cursor: move;
      flex-shrink: 0;
    }

    .task-status {
      width: 8px;
      height: 8px;
      border-radius: 50%;
      margin-right: 0.5rem;
    }

    .status-pending { background: var(--warning); }
    .status-progress { background: var(--primary); }
    .status-complete { background: var(--secondary); }

    .task-title {
      font-weight: 600;
      color: var(--dark);
      flex: 1;
    }

    .task-actions {
      display: flex;
      gap: 0.5rem;
    }

    .task-action {
      background: none;
      border: none;
      cursor: pointer;
      color: var(--dark);
      padding: 0.25rem;
      border-radius: 4px;
      transition: background 0.2s ease;
    }

    .task-action:hover {
      background: rgba(0, 0, 0, 0.1);
    }

    .task-body {
      padding: 1rem;
      overflow: auto;
      flex: 1;
      min-height: 0;
    }

    .task-description {
      color: #666;
      font-size: 14px;
      margin-bottom: 1rem;
      line-height: 1.5;
      word-wrap: break-word;
      word-break: break-word;
      white-space: pre-wrap;
      overflow-wrap: break-word;
      max-width: 100%;
    }

    .task-meta {
      display: flex;
      gap: 1rem;
      font-size: 12px;
      color: #999;
      min-height: 0;
      flex-shrink: 0;
    }
    
    .task-meta:empty {
      display: none;
    }

    .task-subtasks {
      margin-top: 1rem;
      padding-top: 1rem;
      border-top: 1px solid var(--border);
    }

    .subtask {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0.25rem 0;
      font-size: 14px;
    }

    .subtask input[type="checkbox"] {
      cursor: pointer;
    }

    .subtask.completed label {
      text-decoration: line-through;
      color: #999;
    }

    /* Text Boxes */
    .text-box {
      position: absolute;
      background: transparent;
      padding: 8px;
      cursor: move;
      user-select: none;
      border: 2px solid transparent;
      transition: border-color 0.2s ease;
    }

    .text-box:hover {
      border-color: rgba(74, 144, 226, 0.3);
    }

    .text-box.selected {
      border-color: var(--primary);
    }

    .text-box.dragging {
      opacity: 0.8;
      cursor: grabbing;
      z-index: 1000;
    }

    .text-content {
      cursor: text;
      padding: 4px;
      min-width: 50px;
      min-height: 20px;
    }

    .text-content[contenteditable="true"] {
      outline: 2px solid var(--primary);
      background: white;
      cursor: text;
    }

    /* Lines */
    .drawn-line {
      cursor: pointer;
      stroke: #4a90e2;
      stroke-width: 2;
      transition: stroke-width 0.2s ease;
    }

    .drawn-line:hover {
      stroke-width: 4;
    }

    .drawn-line.selected {
      stroke: var(--primary);
      stroke-width: 4;
    }

    .line-arrow {
      cursor: pointer;
    }

    .line-handle {
      fill: var(--primary);
      stroke: white;
      stroke-width: 2;
      cursor: move;
      opacity: 0;
      transition: opacity 0.2s ease;
    }

    .line-svg.line-selected .line-handle {
      opacity: 1;
    }

    /* Connection Lines */
    .connection {
      position: absolute;
      pointer-events: none;
      z-index: 1;
    }

    .connection-line {
      stroke: var(--primary);
      stroke-width: 2;
      fill: none;
      opacity: 0.6;
    }

    .connection-arrow {
      fill: var(--primary);
      opacity: 0.6;
    }

    /* Properties Panel */
    .properties-panel {
      width: 300px;
      background: white;
      border-left: 1px solid var(--border);
      padding: 1.5rem;
      overflow-y: auto;
      display: none;
      position: relative;
      z-index: 50;
    }

    .properties-panel.active {
      display: block !important;
    }

    .property-group {
      margin-bottom: 1.5rem;
    }

    .property-label {
      font-size: 12px;
      font-weight: 600;
      color: #666;
      text-transform: uppercase;
      margin-bottom: 0.5rem;
    }

    .property-input {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
      transition: border-color 0.3s ease;
    }

    .property-input:focus {
      outline: none;
      border-color: var(--primary);
    }

    .property-textarea {
      min-height: 80px;
      resize: vertical;
    }

    .property-select {
      width: 100%;
      padding: 0.5rem;
      border: 1px solid var(--border);
      border-radius: 4px;
      font-size: 14px;
      background: white;
      cursor: pointer;
    }

    /* Context Menu */
    .context-menu {
      position: fixed;
      background: white;
      border: 1px solid var(--border);
      border-radius: 4px;
      box-shadow: 0 2px 10px var(--shadow);
      display: none;
      z-index: 1500;
      min-width: 150px;
    }

    .context-menu.active {
      display: block;
    }

    .context-item {
      padding: 0.5rem 1rem;
      cursor: pointer;
      transition: background 0.2s ease;
      font-size: 14px;
    }

    .context-item:hover {
      background: var(--light);
    }

    .context-divider {
      height: 1px;
      background: var(--border);
      margin: 0.25rem 0;
    }

    /* Toolbar */
    .toolbar {
      background: white;
      border-bottom: 1px solid var(--border);
      padding: 0.5rem 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
      box-shadow: 0 2px 4px var(--shadow);
    }

    .tool-group {
      display: flex;
      align-items: center;
      gap: 0.5rem;
      padding: 0 1rem;
      border-right: 1px solid var(--border);
    }

    .tool-group:last-child {
      border-right: none;
    }

    .tool-btn {
      background: none;
      border: 1px solid transparent;
      padding: 0.5rem;
      cursor: pointer;
      border-radius: 4px;
      transition: all 0.2s ease;
      display: flex;
      align-items: center;
      justify-content: center;
    }

    .tool-btn:hover {
      background: var(--light);
    }

    .tool-btn.active {
      background: var(--primary);
      color: white;
    }

    /* Icons */
    .icon {
      width: 20px;
      height: 20px;
    }

    /* Notifications */
    .notification {
      position: fixed;
      bottom: 2rem;
      right: 2rem;
      background: var(--dark);
      color: white;
      padding: 1rem 1.5rem;
      border-radius: 4px;
      box-shadow: 0 4px 12px rgba(0, 0, 0, 0.15);
      transform: translateY(100px);
      opacity: 0;
      transition: all 0.3s ease;
      z-index: 3000;
    }

    .notification.show {
      transform: translateY(0);
      opacity: 1;
    }

    /* Responsive */
    @media (max-width: 768px) {
      .sidebar {
        width: 200px;
      }
      
      .properties-panel {
        width: 250px;
      }
    }
  </style>
</head>
<body>
  <!-- Header -->
  <header class="header">
    <h1>NAJ Task Manager</h1>
    <div class="header-actions">
      <button class="btn btn-secondary" onclick="taskManager.exportDiagram()">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="18" height="18" rx="2" ry="2"></rect>
          <polyline points="9 9 9 15 12 12 15 15 15 9"></polyline>
        </svg>
        Export Diagram
      </button>
      <button class="btn btn-secondary" onclick="taskManager.exportList()">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="8" y1="6" x2="21" y2="6"></line>
          <line x1="8" y1="12" x2="21" y2="12"></line>
          <line x1="8" y1="18" x2="21" y2="18"></line>
          <line x1="3" y1="6" x2="3.01" y2="6"></line>
          <line x1="3" y1="12" x2="3.01" y2="12"></line>
          <line x1="3" y1="18" x2="3.01" y2="18"></line>
        </svg>
        Export List
      </button>
      <button class="btn btn-secondary" onclick="taskManager.clearAll()">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 6h18"></path>
          <path d="M19 6v14a2 2 0 0 1-2 2H7a2 2 0 0 1-2-2V6m3 0V4a2 2 0 0 1 2-2h4a2 2 0 0 1 2 2v2"></path>
        </svg>
        Clear All
      </button>
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="taskManager.zoomIn()" title="Zoom In">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="11" y1="8" x2="11" y2="14"></line>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
      <span id="zoomLevel" style="min-width: 50px; text-align: center;">100%</span>
      <button class="tool-btn" onclick="taskManager.zoomOut()" title="Zoom Out">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <circle cx="11" cy="11" r="8"></circle>
          <path d="m21 21-4.35-4.35"></path>
          <line x1="8" y1="11" x2="14" y2="11"></line>
        </svg>
      </button>
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="taskManager.toggleGrid()" title="Toggle Grid">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <rect x="3" y="3" width="6" height="6"></rect>
          <rect x="9" y="3" width="6" height="6"></rect>
          <rect x="15" y="3" width="6" height="6"></rect>
          <rect x="3" y="9" width="6" height="6"></rect>
          <rect x="9" y="9" width="6" height="6"></rect>
          <rect x="15" y="9" width="6" height="6"></rect>
          <rect x="3" y="15" width="6" height="6"></rect>
          <rect x="9" y="15" width="6" height="6"></rect>
          <rect x="15" y="15" width="6" height="6"></rect>
        </svg>
      </button>
      <input type="color" id="bgColorPicker" value="#f5f7fa" title="Background Color" style="width: 40px; height: 32px; border: 1px solid var(--border); border-radius: 4px; cursor: pointer;" onchange="taskManager.changeBackgroundColor(this.value)">
    </div>
  </header>

  <!-- Toolbar -->
  <div class="toolbar">
    <div class="tool-group">
      <button class="tool-btn active" onclick="taskManager.setTool('select')" title="Select">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M3 3l7.07 16.97 2.51-7.39 7.39-2.51L3 3z"></path>
        </svg>
      </button>
      <button class="tool-btn" onclick="taskManager.setTool('connect')" title="Draw Lines">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <line x1="5" y1="12" x2="19" y2="12"></line>
          <polyline points="12 5 19 12 12 19"></polyline>
        </svg>
      </button>
      <button class="tool-btn" onclick="taskManager.setTool('textbox')" title="Add Text Box">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <path d="M14 2H6a2 2 0 0 0-2 2v16a2 2 0 0 0 2 2h12a2 2 0 0 0 2-2V8z"></path>
          <polyline points="14,2 14,8 20,8"></polyline>
          <line x1="16" y1="13" x2="8" y2="13"></line>
          <line x1="16" y1="17" x2="8" y2="17"></line>
          <polyline points="10,9 9,9 8,9"></polyline>
        </svg>
      </button>
    </div>
    <div class="tool-group">
      <button class="tool-btn" onclick="taskManager.undo()" title="Undo">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="9 14 4 9 9 4"></polyline>
          <path d="M20 20v-7a4 4 0 0 0-4-4H4"></path>
        </svg>
      </button>
      <button class="tool-btn" onclick="taskManager.redo()" title="Redo">
        <svg class="icon" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
          <polyline points="15 14 20 9 15 4"></polyline>
          <path d="M4 20v-7a4 4 0 0 1 4-4h12"></path>
        </svg>
      </button>
    </div>
    <div class="tool-group">
      <span>Project:</span>
      <select id="projectSelector" class="property-select" style="width: 200px;" onchange="taskManager.switchProject(this.value)">
        <option value="default">Default Project</option>
      </select>
      <button class="btn btn-primary" onclick="taskManager.createProject()">New Project</button>
    </div>
  </div>

  <!-- Main Container -->
  <div class="main-container">
    <!-- Sidebar -->
    <aside class="sidebar">
      <div class="sidebar-header">
        <button class="btn btn-primary" style="width: 100%;" onclick="taskManager.createTask()">
          + Add Task
        </button>
      </div>
      <div class="project-list" id="taskList">
        <!-- Tasks will be listed here -->
      </div>
    </aside>

    <!-- Canvas Area -->
    <div class="canvas-area" id="canvasArea">
      <div class="canvas" id="canvas">
        <svg id="connectionSvg" style="position: absolute; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none;">
          <!-- Connections will be drawn here -->
        </svg>
        <!-- Task cards will be added here -->
      </div>
    </div>

    <!-- Properties Panel -->
    <aside class="properties-panel" id="propertiesPanel">
      <!-- Properties content will be dynamically inserted here -->
    </aside>
  </div>

  <!-- Context Menu -->
  <div class="context-menu" id="contextMenu">
    <div class="context-item" onclick="taskManager.contextAction('add')">Add Task</div>
    <div class="context-divider"></div>
    <div class="context-item" onclick="taskManager.contextAction('edit')">Edit Task</div>
    <div class="context-item" onclick="taskManager.contextAction('duplicate')">Duplicate</div>
    <div class="context-divider"></div>
    <div class="context-item" onclick="taskManager.contextAction('connect')">Connect To...</div>
    <div class="context-item" onclick="taskManager.contextAction('disconnect')">Remove Connections</div>
    <div class="context-divider"></div>
    <div class="context-item" onclick="taskManager.contextAction('delete')">Delete</div>
  </div>

  <!-- Notification -->
  <div class="notification" id="notification"></div>

  <script>
    class TaskManager {
      constructor() {
        this.currentProject = 'default';
        this.projects = {
          default: {
            name: 'Default Project',
            tasks: {},
            textBoxes: {},
            lines: [],
            connections: []
          }
        };
        this.selectedTask = null;
        this.selectedTextBox = null;
        this.selectedLine = null;
        this.currentTool = 'select';
        this.draggedTask = null;
        this.connectionStart = null;
        this.drawingLine = false;
        this.lineStart = null;
        this.draggingLine = null;
        this.draggingLineEnd = null;
        this.undoStack = [];
        this.redoStack = [];
        this.taskIdCounter = 0;
        this.textBoxIdCounter = 0;
        this.lineIdCounter = 0;
        this.zoom = 1;
        this.gridVisible = true;
        this.backgroundColor = '#f5f7fa';
        this.saveTimeout = null;
        
        this.init();
      }

      init() {
        // Load saved data
        this.loadFromLocalStorage();
        
        // Set up event listeners
        this.setupEventListeners();
        
        // Render initial state
        this.renderTasks();
        this.updateProjectSelector();
        
        // Save state for undo
        this.saveState();
      }

      setupEventListeners() {
        const canvas = document.getElementById('canvas');
        const canvasArea = document.getElementById('canvasArea');
        
        // Canvas click events
        canvas.addEventListener('click', (e) => {
          if (e.target.id === 'canvas') {
            if (this.currentTool === 'textbox') {
              const rect = canvas.getBoundingClientRect();
              const scrollLeft = canvasArea.scrollLeft;
              const scrollTop = canvasArea.scrollTop;
              const x = (e.clientX - rect.left + scrollLeft) / this.zoom;
              const y = (e.clientY - rect.top + scrollTop) / this.zoom;
              this.createTextBox(x, y);
              this.showNotification('Double-click text to edit');
            } else if (this.currentTool === 'connect') {
              const rect = canvas.getBoundingClientRect();
              const scrollLeft = canvasArea.scrollLeft;
              const scrollTop = canvasArea.scrollTop;
              const x = (e.clientX - rect.left + scrollLeft) / this.zoom;
              const y = (e.clientY - rect.top + scrollTop) / this.zoom;
              
              if (!this.drawingLine) {
                this.startDrawingLine(x, y);
              } else {
                this.finishDrawingLine(x, y);
              }
            } else {
              this.selectTask(null);
              this.selectTextBox(null);
              this.selectLine(null);
            }
          }
        });
        
        canvas.addEventListener('contextmenu', (e) => this.handleContextMenu(e));
        
        // Mouse wheel zoom
        canvasArea.addEventListener('wheel', (e) => {
          if (e.ctrlKey || e.metaKey) {
            e.preventDefault();
            const delta = e.deltaY > 0 ? -0.1 : 0.1;
            this.setZoom(this.zoom + delta);
          }
        });
        
        // Hide context menu on click
        document.addEventListener('click', () => {
          document.getElementById('contextMenu').classList.remove('active');
        });
        
        // Keyboard shortcuts
        document.addEventListener('keydown', (e) => {
          if (e.ctrlKey || e.metaKey) {
            switch(e.key) {
              case 'z':
                e.preventDefault();
                this.undo();
                break;
              case 'y':
                e.preventDefault();
                this.redo();
                break;
              case 's':
                e.preventDefault();
                this.saveToLocalStorage();
                this.showNotification('Project saved');
                break;
              case '=':
              case '+':
                e.preventDefault();
                this.zoomIn();
                break;
              case '-':
                e.preventDefault();
                this.zoomOut();
                break;
            }
          } else if (e.key === 'Delete') {
            if (this.selectedTask) {
              this.deleteSelectedTask();
            } else if (this.selectedTextBox) {
              this.deleteTextBox(this.selectedTextBox);
            } else if (this.selectedLine) {
              this.deleteLine(this.selectedLine);
            }
          }
        });
      }

      handleContextMenu(e) {
        e.preventDefault();
        const taskCard = e.target.closest('.task-card');
        const lineElement = e.target.closest('.drawn-line');
        
        if (taskCard) {
          this.showContextMenu(e.clientX, e.clientY, taskCard.dataset.taskId);
        } else if (lineElement) {
          this.showLineContextMenu(e.clientX, e.clientY, lineElement.dataset.lineId);
        } else if (e.target.id === 'canvas') {
          this.showCanvasContextMenu(e.clientX, e.clientY, e);
        }
      }

      showCanvasContextMenu(x, y, e) {
        const menu = document.getElementById('contextMenu');
        menu.innerHTML = `
          <div class="context-item" onclick="taskManager.contextAction('add')">Add Task Here</div>
          <div class="context-divider"></div>
          <div class="context-item" onclick="taskManager.toggleGrid()">Toggle Grid</div>
          <div class="context-item" onclick="taskManager.promptBackgroundColor()">Change Background Color</div>
        `;
        
        const rect = e.target.getBoundingClientRect();
        const canvasArea = document.getElementById('canvasArea');
        const canvasX = (e.clientX - rect.left + canvasArea.scrollLeft) / this.zoom;
        const canvasY = (e.clientY - rect.top + canvasArea.scrollTop) / this.zoom;
        
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('active');
        menu.dataset.canvasX = canvasX;
        menu.dataset.canvasY = canvasY;
        menu.dataset.isCanvas = 'true';
      }

      showLineContextMenu(x, y, lineId) {
        const menu = document.getElementById('contextMenu');
        menu.innerHTML = `
          <div class="context-item" onclick="taskManager.deleteLine('${lineId}')">Delete Line</div>
        `;
        
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('active');
      }

      showContextMenu(x, y, taskId) {
        const menu = document.getElementById('contextMenu');
        menu.innerHTML = `
          <div class="context-item" onclick="taskManager.contextAction('edit')">Edit Task</div>
          <div class="context-item" onclick="taskManager.contextAction('duplicate')">Duplicate</div>
          <div class="context-divider"></div>
          <div class="context-item" onclick="taskManager.contextAction('connect')">Connect To...</div>
          <div class="context-item" onclick="taskManager.contextAction('disconnect')">Remove Connections</div>
          <div class="context-divider"></div>
          <div class="context-item" onclick="taskManager.contextAction('delete')">Delete</div>
        `;
        
        menu.style.left = `${x}px`;
        menu.style.top = `${y}px`;
        menu.classList.add('active');
        menu.dataset.taskId = taskId;
        menu.dataset.isCanvas = 'false';
      }

      contextAction(action) {
        const menu = document.getElementById('contextMenu');
        const isCanvas = menu.dataset.isCanvas === 'true';
        
        if (isCanvas && action === 'add') {
          const x = parseFloat(menu.dataset.canvasX);
          const y = parseFloat(menu.dataset.canvasY);
          this.createTask(x, y);
        } else {
          const taskId = menu.dataset.taskId;
          
          switch(action) {
            case 'edit':
              this.selectTask(taskId);
              break;
            case 'duplicate':
              this.duplicateTask(taskId);
              break;
            case 'delete':
              this.deleteTask(taskId);
              break;
            case 'connect':
              this.startConnection(taskId);
              break;
            case 'disconnect':
              this.removeConnections(taskId);
              break;
          }
        }
        
        menu.classList.remove('active');
      }

      createTask(x, y) {
        const taskId = `task_${++this.taskIdCounter}`;
        const task = {
          id: taskId,
          title: 'New Task',
          description: '',
          status: 'pending',
          x: x || 100,
          y: y || 100,
          subtasks: [],
          createdAt: new Date().toISOString(),
          dueDate: null,
          style: {
            backgroundColor: '#ffffff',
            borderColor: '#4a90e2',
            width: '250px',
            height: 'auto'
          }
        };
        
        this.projects[this.currentProject].tasks[taskId] = task;
        
        // Re-render all tasks
        this.renderTasks();
        this.selectTask(taskId);
        this.saveState();
        this.saveToLocalStorage();
        this.showNotification('Task created');
      }

      createTextBox(x, y) {
        const textBoxId = `textbox_${++this.textBoxIdCounter}`;
        const textBox = {
          id: textBoxId,
          text: 'Double-click to edit',
          x: x || 100,
          y: y || 100,
          style: {
            fontSize: '14px',
            fontWeight: 'normal',
            color: '#2c3e50',
            width: '200px'
          }
        };
        
        this.projects[this.currentProject].textBoxes[textBoxId] = textBox;
        this.renderTextBox(textBox);
        this.selectTextBox(textBoxId);
        this.saveState();
        this.saveToLocalStorage();
      }

      renderTextBox(textBox) {
        const canvas = document.getElementById('canvas');
        const textBoxElement = document.createElement('div');
        textBoxElement.className = 'text-box';
        textBoxElement.dataset.textboxId = textBox.id;
        textBoxElement.style.left = `${textBox.x}px`;
        textBoxElement.style.top = `${textBox.y}px`;
        
        if (textBox.style) {
          textBoxElement.style.fontSize = textBox.style.fontSize || '14px';
          textBoxElement.style.fontWeight = textBox.style.fontWeight || 'normal';
          textBoxElement.style.color = textBox.style.color || '#2c3e50';
          textBoxElement.style.width = textBox.style.width || '200px';
        }
        
        // Escape HTML function
        const escapeHtml = (str) => {
          const div = document.createElement('div');
          div.textContent = str;
          return div.innerHTML;
        };
        
        textBoxElement.innerHTML = `
          <div class="text-content" ondblclick="taskManager.editTextBox('${textBox.id}')">${escapeHtml(textBox.text)}</div>
        `;
        
        canvas.appendChild(textBoxElement);
        this.makeTextBoxDraggable(textBoxElement);
      }

      makeTextBoxDraggable(element) {
        let isDragging = false;
        let startX, startY, initialX, initialY;
        
        element.addEventListener('mousedown', (e) => {
          if (e.target.classList.contains('text-content') && e.target.contentEditable === 'true') return;
          
          isDragging = true;
          element.classList.add('dragging');
          
          startX = e.clientX;
          startY = e.clientY;
          initialX = element.offsetLeft;
          initialY = element.offsetTop;
          
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          
          element.style.left = `${initialX + dx}px`;
          element.style.top = `${initialY + dy}px`;
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            
            const textBoxId = element.dataset.textboxId;
            const textBox = this.projects[this.currentProject].textBoxes[textBoxId];
            if (textBox) {
              textBox.x = element.offsetLeft;
              textBox.y = element.offsetTop;
              this.saveToLocalStorage();
              this.saveState();
            }
          }
        });
        
        element.addEventListener('click', (e) => {
          if (!e.target.classList.contains('text-content') || e.target.contentEditable !== 'true') {
            this.selectTextBox(element.dataset.textboxId);
          }
        });
      }

      selectTextBox(textBoxId) {
        // Clear all selections
        document.querySelectorAll('.text-box').forEach(box => {
          box.classList.remove('selected');
        });
        document.querySelectorAll('.task-card').forEach(card => {
          card.classList.remove('selected');
        });
        document.querySelectorAll('.drawn-line').forEach(line => {
          line.classList.remove('selected');
        });
        document.querySelectorAll('.line-svg').forEach(svg => {
          svg.classList.remove('line-selected');
        });
        
        this.selectedTask = null;
        this.selectedLine = null;
        
        if (textBoxId) {
          const textBoxElement = document.querySelector(`[data-textbox-id="${textBoxId}"]`);
          if (textBoxElement) {
            textBoxElement.classList.add('selected');
            this.selectedTextBox = textBoxId;
            this.showTextBoxProperties(textBoxId);
          }
        } else {
          this.selectedTextBox = null;
          this.hideProperties();
        }
      }

      editTextBox(textBoxId) {
        const textBoxElement = document.querySelector(`[data-textbox-id="${textBoxId}"]`);
        const textContent = textBoxElement.querySelector('.text-content');
        
        textContent.contentEditable = true;
        textContent.focus();
        
        const range = document.createRange();
        range.selectNodeContents(textContent);
        const selection = window.getSelection();
        selection.removeAllRanges();
        selection.addRange(range);
        
        const saveText = () => {
          textContent.contentEditable = false;
          const textBox = this.projects[this.currentProject].textBoxes[textBoxId];
          if (textBox) {
            textBox.text = textContent.textContent || 'Double-click to edit';
            this.saveToLocalStorage();
            this.saveState();
          }
        };
        
        textContent.addEventListener('blur', saveText, { once: true });
        textContent.addEventListener('keydown', (e) => {
          if (e.key === 'Enter' && !e.shiftKey) {
            e.preventDefault();
            saveText();
          }
        });
      }

      showTextBoxProperties(textBoxId) {
        const textBox = this.projects[this.currentProject].textBoxes[textBoxId];
        if (!textBox) return;
        
        const panel = document.getElementById('propertiesPanel');
        panel.classList.add('active');
        
        // Escape HTML function
        const escapeHtml = (str) => {
          const div = document.createElement('div');
          div.textContent = str;
          return div.innerHTML;
        };
        
        panel.innerHTML = `
          <h3>Text Box Properties</h3>
          <div class="property-group">
            <label class="property-label">Text</label>
            <textarea class="property-input property-textarea" id="textBoxTextInput" placeholder="Enter text">${escapeHtml(textBox.text)}</textarea>
          </div>
          <div class="property-group">
            <label class="property-label">Font Size</label>
            <select class="property-select" id="textBoxFontSize">
              <option value="12px" ${textBox.style?.fontSize === '12px' ? 'selected' : ''}>Small (12px)</option>
              <option value="14px" ${textBox.style?.fontSize === '14px' ? 'selected' : ''}>Normal (14px)</option>
              <option value="16px" ${textBox.style?.fontSize === '16px' ? 'selected' : ''}>Medium (16px)</option>
              <option value="20px" ${textBox.style?.fontSize === '20px' ? 'selected' : ''}>Large (20px)</option>
              <option value="24px" ${textBox.style?.fontSize === '24px' ? 'selected' : ''}>X-Large (24px)</option>
              <option value="32px" ${textBox.style?.fontSize === '32px' ? 'selected' : ''}>Heading (32px)</option>
            </select>
          </div>
          <div class="property-group">
            <label class="property-label">Font Weight</label>
            <select class="property-select" id="textBoxFontWeight">
              <option value="normal" ${textBox.style?.fontWeight === 'normal' ? 'selected' : ''}>Normal</option>
              <option value="bold" ${textBox.style?.fontWeight === 'bold' ? 'selected' : ''}>Bold</option>
            </select>
          </div>
          <div class="property-group">
            <label class="property-label">Text Color</label>
            <input type="color" class="property-input" id="textBoxColor" value="${textBox.style?.color || '#2c3e50'}">
          </div>
          <div class="property-group">
            <label class="property-label">Width</label>
            <input type="number" class="property-input" id="textBoxWidth" value="${parseInt(textBox.style?.width) || 200}" min="50" max="800">
          </div>
          <div class="property-group">
            <button class="btn btn-danger" onclick="taskManager.deleteTextBox('${textBoxId}')">Delete Text Box</button>
          </div>
        `;
        
        document.getElementById('textBoxTextInput').addEventListener('input', (e) => this.updateTextBoxProperty('text', e.target.value));
        document.getElementById('textBoxFontSize').addEventListener('change', (e) => this.updateTextBoxStyle('fontSize', e.target.value));
        document.getElementById('textBoxFontWeight').addEventListener('change', (e) => this.updateTextBoxStyle('fontWeight', e.target.value));
        document.getElementById('textBoxColor').addEventListener('change', (e) => this.updateTextBoxStyle('color', e.target.value));
        document.getElementById('textBoxWidth').addEventListener('input', (e) => this.updateTextBoxStyle('width', e.target.value + 'px'));
      }

      updateTextBoxProperty(property, value) {
        if (!this.selectedTextBox) return;
        
        const textBox = this.projects[this.currentProject].textBoxes[this.selectedTextBox];
        if (textBox) {
          textBox[property] = value;
          
          // Update display
          const textBoxElement = document.querySelector(`[data-textbox-id="${this.selectedTextBox}"]`);
          if (textBoxElement && property === 'text') {
            const textContent = textBoxElement.querySelector('.text-content');
            if (textContent) {
              textContent.textContent = value;
            }
          }
          
          // Use debounced save for text changes
          this.debouncedSave();
        }
      }

      updateTextBoxStyle(property, value) {
        if (!this.selectedTextBox) return;
        
        const textBox = this.projects[this.currentProject].textBoxes[this.selectedTextBox];
        if (textBox) {
          if (!textBox.style) {
            textBox.style = {
              fontSize: '14px',
              fontWeight: 'normal',
              color: '#2c3e50',
              width: '200px'
            };
          }
          
          textBox.style[property] = value;
          
          const textBoxElement = document.querySelector(`[data-textbox-id="${this.selectedTextBox}"]`);
          if (textBoxElement) {
            textBoxElement.style[property] = value;
          }
          
          this.saveToLocalStorage();
          // Don't save state for style changes
        }
      }

      deleteTextBox(textBoxId) {
        if (confirm('Are you sure you want to delete this text box?')) {
          delete this.projects[this.currentProject].textBoxes[textBoxId];
          this.renderTextBoxes();
          this.hideProperties();
          this.selectedTextBox = null;
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Text box deleted');
        }
      }

      renderTextBoxes() {
        const canvas = document.getElementById('canvas');
        const textBoxElements = canvas.querySelectorAll('.text-box');
        textBoxElements.forEach(element => element.remove());
        
        Object.values(this.projects[this.currentProject].textBoxes || {}).forEach(textBox => {
          this.renderTextBox(textBox);
        });
      }

      // Line drawing functionality
      startDrawingLine(x, y) {
        this.drawingLine = true;
        this.lineStart = { x, y };
        this.showNotification('Click to end line');
      }

      finishDrawingLine(x, y) {
        if (this.lineStart) {
          const lineId = `line_${++this.lineIdCounter}`;
          const line = {
            id: lineId,
            x1: this.lineStart.x,
            y1: this.lineStart.y,
            x2: x,
            y2: y,
            style: {
              color: '#4a90e2',
              width: 2
            }
          };
          
          this.projects[this.currentProject].lines.push(line);
          this.renderLines();
          this.saveState();
          this.saveToLocalStorage();
          this.showNotification('Line created');
        }
        
        this.drawingLine = false;
        this.lineStart = null;
      }

      renderLines() {
        const canvas = document.getElementById('canvas');
        const existingSvg = canvas.querySelector('.line-svg');
        if (existingSvg) {
          existingSvg.remove();
        }
        
        const svg = document.createElementNS('http://www.w3.org/2000/svg', 'svg');
        svg.setAttribute('class', 'line-svg');
        svg.style.position = 'absolute';
        svg.style.top = '0';
        svg.style.left = '0';
        svg.style.width = '100%';
        svg.style.height = '100%';
        svg.style.pointerEvents = 'none';
        svg.style.zIndex = '5';
        
        this.projects[this.currentProject].lines.forEach(line => {
          const lineElement = document.createElementNS('http://www.w3.org/2000/svg', 'line');
          lineElement.setAttribute('x1', line.x1);
          lineElement.setAttribute('y1', line.y1);
          lineElement.setAttribute('x2', line.x2);
          lineElement.setAttribute('y2', line.y2);
          lineElement.setAttribute('class', 'drawn-line');
          lineElement.setAttribute('data-line-id', line.id);
          lineElement.style.pointerEvents = 'auto';
          
          if (line.style) {
            lineElement.style.stroke = line.style.color || '#4a90e2';
            lineElement.style.strokeWidth = line.style.width || '2';
          }
          
          // Add arrow at the end
          const angle = Math.atan2(line.y2 - line.y1, line.x2 - line.x1);
          const arrowSize = 10;
          const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
          arrow.setAttribute('points', `
            ${line.x2},${line.y2} 
            ${line.x2 - arrowSize * Math.cos(angle - Math.PI / 6)},${line.y2 - arrowSize * Math.sin(angle - Math.PI / 6)} 
            ${line.x2 - arrowSize * Math.cos(angle + Math.PI / 6)},${line.y2 - arrowSize * Math.sin(angle + Math.PI / 6)}
          `);
          arrow.setAttribute('class', 'line-arrow');
          arrow.style.fill = line.style?.color || '#4a90e2';
          arrow.style.pointerEvents = 'auto';
          arrow.setAttribute('data-line-id', line.id);
          
          // Add handles for dragging
          const handle1 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          handle1.setAttribute('cx', line.x1);
          handle1.setAttribute('cy', line.y1);
          handle1.setAttribute('r', '8');
          handle1.setAttribute('class', 'line-handle');
          handle1.setAttribute('data-line-id', line.id);
          handle1.setAttribute('data-handle', 'start');
          
          const handle2 = document.createElementNS('http://www.w3.org/2000/svg', 'circle');
          handle2.setAttribute('cx', line.x2);
          handle2.setAttribute('cy', line.y2);
          handle2.setAttribute('r', '8');
          handle2.setAttribute('class', 'line-handle');
          handle2.setAttribute('data-line-id', line.id);
          handle2.setAttribute('data-handle', 'end');
          
          lineElement.addEventListener('click', (e) => {
            e.stopPropagation();
            this.selectLine(line.id);
          });
          
          arrow.addEventListener('click', (e) => {
            e.stopPropagation();
            this.selectLine(line.id);
          });
          
          lineElement.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.showLineContextMenu(e.clientX, e.clientY, line.id);
          });
          
          arrow.addEventListener('contextmenu', (e) => {
            e.preventDefault();
            e.stopPropagation();
            this.showLineContextMenu(e.clientX, e.clientY, line.id);
          });
          
          // Handle dragging
          this.makeLineDraggable(handle1, line, 'start');
          this.makeLineDraggable(handle2, line, 'end');
          
          svg.appendChild(lineElement);
          svg.appendChild(arrow);
          svg.appendChild(handle1);
          svg.appendChild(handle2);
        });
        
        canvas.appendChild(svg);
      }

      makeLineDraggable(handle, line, handleType) {
        let isDragging = false;
        
        handle.addEventListener('mousedown', (e) => {
          e.preventDefault();
          e.stopPropagation();
          isDragging = true;
          this.selectLine(line.id);
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          
          const canvas = document.getElementById('canvas');
          const canvasArea = document.getElementById('canvasArea');
          const rect = canvas.getBoundingClientRect();
          const x = (e.clientX - rect.left + canvasArea.scrollLeft) / this.zoom;
          const y = (e.clientY - rect.top + canvasArea.scrollTop) / this.zoom;
          
          if (handleType === 'start') {
            line.x1 = x;
            line.y1 = y;
          } else {
            line.x2 = x;
            line.y2 = y;
          }
          
          this.renderLines();
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            this.saveToLocalStorage();
            this.saveState();
          }
        });
      }

      selectLine(lineId) {
        document.querySelectorAll('.drawn-line').forEach(line => {
          line.classList.remove('selected');
        });
        
        document.querySelectorAll('.line-svg').forEach(svg => {
          svg.classList.remove('line-selected');
        });
        
        this.selectTask(null);
        this.selectTextBox(null);
        
        if (lineId) {
          const lineElement = document.querySelector(`[data-line-id="${lineId}"]`);
          if (lineElement) {
            lineElement.classList.add('selected');
            lineElement.parentElement.classList.add('line-selected');
            this.selectedLine = lineId;
            this.showLineProperties(lineId);
          }
        } else {
          this.selectedLine = null;
          this.hideProperties();
        }
      }

      showLineProperties(lineId) {
        const line = this.projects[this.currentProject].lines.find(l => l.id === lineId);
        if (!line) return;
        
        const panel = document.getElementById('propertiesPanel');
        panel.classList.add('active');
        
        panel.innerHTML = `
          <h3>Line Properties</h3>
          <div class="property-group">
            <label class="property-label">Line Color</label>
            <input type="color" class="property-input" id="lineColor" value="${line.style?.color || '#4a90e2'}">
          </div>
          <div class="property-group">
            <label class="property-label">Line Width</label>
            <select class="property-select" id="lineWidth">
              <option value="1" ${line.style?.width === 1 ? 'selected' : ''}>Thin (1px)</option>
              <option value="2" ${line.style?.width === 2 ? 'selected' : ''}>Normal (2px)</option>
              <option value="3" ${line.style?.width === 3 ? 'selected' : ''}>Medium (3px)</option>
              <option value="4" ${line.style?.width === 4 ? 'selected' : ''}>Thick (4px)</option>
              <option value="6" ${line.style?.width === 6 ? 'selected' : ''}>Very Thick (6px)</option>
            </select>
          </div>
          <div class="property-group">
            <button class="btn btn-danger" onclick="taskManager.deleteLine('${lineId}')">Delete Line</button>
          </div>
        `;
        
        document.getElementById('lineColor').addEventListener('change', (e) => this.updateLineStyle('color', e.target.value));
        document.getElementById('lineWidth').addEventListener('change', (e) => this.updateLineStyle('width', parseInt(e.target.value)));
      }

      updateLineStyle(property, value) {
        if (!this.selectedLine) return;
        
        const line = this.projects[this.currentProject].lines.find(l => l.id === this.selectedLine);
        if (line) {
          if (!line.style) {
            line.style = { color: '#4a90e2', width: 2 };
          }
          
          line.style[property] = value;
          this.renderLines();
          this.saveToLocalStorage();
          // Don't save state for style changes
        }
      }

      deleteLine(lineId) {
        if (confirm('Are you sure you want to delete this line?')) {
          this.projects[this.currentProject].lines = this.projects[this.currentProject].lines.filter(l => l.id !== lineId);
          this.renderLines();
          this.hideProperties();
          this.selectedLine = null;
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Line deleted');
        }
      }

      renderTask(task) {
        const canvas = document.getElementById('canvas');
        
        // Check if task card already exists and get its current dimensions
        const existingCard = document.querySelector(`[data-task-id="${task.id}"]`);
        let currentWidth = null;
        let currentHeight = null;
        if (existingCard) {
          currentWidth = existingCard.offsetWidth;
          currentHeight = existingCard.offsetHeight;
          existingCard.remove();
        }
        
        const taskCard = document.createElement('div');
        taskCard.className = 'task-card';
        taskCard.dataset.taskId = task.id;
        taskCard.style.left = `${task.x}px`;
        taskCard.style.top = `${task.y}px`;
        
        // Apply saved styles including dimensions
        if (task.style) {
          taskCard.style.backgroundColor = task.style.backgroundColor || '#ffffff';
          taskCard.style.borderColor = task.style.borderColor || '#4a90e2';
          
          // Use current dimensions if available, otherwise use saved dimensions
          if (currentWidth && currentHeight) {
            taskCard.style.width = `${currentWidth}px`;
            taskCard.style.height = `${currentHeight}px`;
          } else if (task.style.width) {
            taskCard.style.width = task.style.width;
            if (task.style.height && task.style.height !== 'auto') {
              taskCard.style.height = task.style.height;
            }
          } else {
            taskCard.style.width = '250px';
          }
        } else {
          taskCard.style.width = '250px';
        }
        
        // Escape HTML function
        const escapeHtml = (str) => {
          const div = document.createElement('div');
          div.textContent = str;
          return div.innerHTML;
        };
        
        taskCard.innerHTML = `
          <div class="task-header">
            <div style="display: flex; align-items: center;">
              <span class="task-status status-${task.status}"></span>
              <span class="task-title">${escapeHtml(task.title)}</span>
            </div>
          </div>
          <div class="task-body">
            ${task.description ? `<p class="task-description">${escapeHtml(task.description)}</p>` : ''}
            <div class="task-meta">
              ${task.dueDate ? `<span>Due: ${new Date(task.dueDate).toLocaleDateString()}</span>` : ''}
              ${task.subtasks.length > 0 ? `<span>${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks</span>` : ''}
            </div>
            ${task.subtasks.length > 0 ? `
              <div class="task-subtasks">
                ${task.subtasks.map((subtask, index) => `
                  <div class="subtask ${subtask.completed ? 'completed' : ''}">
                    <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
                      onchange="taskManager.toggleSubtask('${task.id}', ${index})">
                    <label>${escapeHtml(subtask.text)}</label>
                  </div>
                `).join('')}
              </div>
            ` : ''}
          </div>
        `;
        
        canvas.appendChild(taskCard);
        this.makeDraggable(taskCard);
        
        // Update sidebar
        this.updateTaskList();
      }

      makeDraggable(element) {
        let isDragging = false;
        let startX, startY, initialX, initialY;
        let isManualResize = false;
        let lastWidth = element.offsetWidth;
        let lastHeight = element.offsetHeight;
        
        const taskHeader = element.querySelector('.task-header');
        
        taskHeader.addEventListener('mousedown', (e) => {
          if (e.target.closest('.task-action')) return;
          
          isDragging = true;
          element.classList.add('dragging');
          
          startX = e.clientX;
          startY = e.clientY;
          initialX = element.offsetLeft;
          initialY = element.offsetTop;
          
          e.preventDefault();
        });
        
        document.addEventListener('mousemove', (e) => {
          if (!isDragging) return;
          
          const dx = e.clientX - startX;
          const dy = e.clientY - startY;
          
          element.style.left = `${initialX + dx}px`;
          element.style.top = `${initialY + dy}px`;
          
          // Update connections
          this.updateConnections();
        });
        
        document.addEventListener('mouseup', () => {
          if (isDragging) {
            isDragging = false;
            element.classList.remove('dragging');
            
            // Update task position in data
            const taskId = element.dataset.taskId;
            const task = this.projects[this.currentProject].tasks[taskId];
            if (task) {
              task.x = element.offsetLeft;
              task.y = element.offsetTop;
              this.saveToLocalStorage();
              this.saveState();
            }
          }
        });
        
        // Click to select - add to both header and card
        element.addEventListener('click', (e) => {
          e.stopPropagation(); // Prevent canvas click
          if (!e.target.closest('.task-action') && !e.target.closest('input[type="checkbox"]')) {
            this.selectTask(element.dataset.taskId);
          }
        });
        
        // Also add click handler to task body
        const taskBody = element.querySelector('.task-body');
        if (taskBody) {
          taskBody.addEventListener('click', (e) => {
            e.stopPropagation();
            if (!e.target.closest('input[type="checkbox"]')) {
              this.selectTask(element.dataset.taskId);
            }
          });
        }
        
        // Detect manual resize
        element.addEventListener('mousedown', (e) => {
          const rect = element.getBoundingClientRect();
          const isNearRightEdge = e.clientX > rect.right - 25;
          const isNearBottomEdge = e.clientY > rect.bottom - 25;
          const isNearBottomRightCorner = isNearRightEdge && isNearBottomEdge;
          
          if (isNearRightEdge || isNearBottomEdge || isNearBottomRightCorner) {
            isManualResize = true;
            lastWidth = element.offsetWidth;
            lastHeight = element.offsetHeight;
          }
        });
        
        document.addEventListener('mouseup', () => {
          if (isManualResize) {
            isManualResize = false;
            
            // Check if size actually changed
            if (element.offsetWidth !== lastWidth || element.offsetHeight !== lastHeight) {
              const taskId = element.dataset.taskId;
              const task = this.projects[this.currentProject].tasks[taskId];
              if (task) {
                if (!task.style) task.style = {};
                task.style.width = `${element.offsetWidth}px`;
                task.style.height = `${element.offsetHeight}px`;
                this.saveToLocalStorage();
                this.saveState();
              }
            }
          }
        });
        
        // Monitor resize for connection updates only
        const resizeObserver = new ResizeObserver(() => {
          this.updateConnections();
        });
        
        resizeObserver.observe(element);
      }

      selectTask(taskId) {
        // Remove all previous selections
        document.querySelectorAll('.task-card').forEach(card => {
          card.classList.remove('selected');
        });
        document.querySelectorAll('.text-box').forEach(box => {
          box.classList.remove('selected');
        });
        document.querySelectorAll('.drawn-line').forEach(line => {
          line.classList.remove('selected');
        });
        document.querySelectorAll('.line-svg').forEach(svg => {
          svg.classList.remove('line-selected');
        });
        
        this.selectedTextBox = null;
        this.selectedLine = null;
        
        if (taskId) {
          const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
          if (taskCard) {
            taskCard.classList.add('selected');
            this.selectedTask = taskId;
            this.showProperties(taskId);
          }
        } else {
          this.selectedTask = null;
          this.hideProperties();
        }
      }

      showProperties(taskId) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (!task) return;
        
        // Save current dimensions of the task card
        const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
        if (taskCard) {
          if (!task.style) task.style = {};
          task.style.width = taskCard.style.width || `${taskCard.offsetWidth}px`;
          task.style.height = taskCard.style.height || `${taskCard.offsetHeight}px`;
        }
        
        const panel = document.getElementById('propertiesPanel');
        
        // Escape values for HTML
        const escapeHtml = (str) => {
          const div = document.createElement('div');
          div.textContent = str;
          return div.innerHTML;
        };
        
        // Set the HTML content first
        panel.innerHTML = `
          <h3>Task Properties</h3>
          <div class="property-group">
            <label class="property-label">Title</label>
            <input type="text" class="property-input" id="taskTitleInput" placeholder="Task title" value="${escapeHtml(task.title)}">
          </div>
          <div class="property-group">
            <label class="property-label">Description</label>
            <textarea class="property-input property-textarea" id="taskDescInput" placeholder="Task description">${escapeHtml(task.description || '')}</textarea>
          </div>
          <div class="property-group">
            <label class="property-label">Status</label>
            <select class="property-select" id="taskStatusInput">
              <option value="pending" ${task.status === 'pending' ? 'selected' : ''}>Pending</option>
              <option value="progress" ${task.status === 'progress' ? 'selected' : ''}>In Progress</option>
              <option value="complete" ${task.status === 'complete' ? 'selected' : ''}>Complete</option>
            </select>
          </div>
          <div class="property-group">
            <label class="property-label">Due Date</label>
            <input type="date" class="property-input" id="taskDueInput" value="${task.dueDate || ''}">
          </div>
          <div class="property-group">
            <label class="property-label">Subtasks</label>
            <div id="subtasksList"></div>
            <button class="btn btn-secondary" style="margin-top: 0.5rem;" onclick="taskManager.addSubtask()">
              + Add Subtask
            </button>
          </div>
          <div class="property-group">
            <label class="property-label">Appearance</label>
            <div style="display: flex; gap: 0.5rem; margin-bottom: 0.5rem;">
              <div style="flex: 1;">
                <label style="font-size: 12px; color: #666;">Fill Color</label>
                <input type="color" class="property-input" id="taskFillColor" value="${task.style?.backgroundColor || '#ffffff'}" onchange="taskManager.updateTaskStyle('backgroundColor', this.value)">
              </div>
              <div style="flex: 1;">
                <label style="font-size: 12px; color: #666;">Border Color</label>
                <input type="color" class="property-input" id="taskBorderColor" value="${task.style?.borderColor || '#4a90e2'}" onchange="taskManager.updateTaskStyle('borderColor', this.value)">
              </div>
            </div>
          </div>
          <div class="property-group">
            <button class="btn btn-danger" onclick="taskManager.deleteSelectedTask()">Delete Task</button>
          </div>
        `;
        
        // Then add the active class
        panel.classList.add('active');
        
        // Add event listeners
        document.getElementById('taskTitleInput').addEventListener('input', (e) => this.updateTaskProperty('title', e.target.value));
        document.getElementById('taskDescInput').addEventListener('input', (e) => this.updateTaskProperty('description', e.target.value));
        document.getElementById('taskStatusInput').addEventListener('change', (e) => this.updateTaskProperty('status', e.target.value));
        document.getElementById('taskDueInput').addEventListener('change', (e) => this.updateTaskProperty('dueDate', e.target.value));
        
        // Render subtasks
        this.renderSubtasks(task);
      }

      hideProperties() {
        const panel = document.getElementById('propertiesPanel');
        panel.classList.remove('active');
        panel.innerHTML = ''; // Clear content to avoid ID conflicts
      }

      debouncedSave() {
        // Clear existing timeout
        if (this.saveTimeout) {
          clearTimeout(this.saveTimeout);
        }
        
        // Set new timeout for saving
        this.saveTimeout = setTimeout(() => {
          this.saveToLocalStorage();
          // Don't save state here - just save to localStorage
        }, 500); // Save after 500ms of no activity
      }

      updateTaskProperty(property, value) {
        if (!this.selectedTask) return;
        
        const task = this.projects[this.currentProject].tasks[this.selectedTask];
        if (task) {
          task[property] = value;
          
          // Update only the specific element instead of re-rendering everything
          const taskCard = document.querySelector(`[data-task-id="${this.selectedTask}"]`);
          if (taskCard) {
            // Save current dimensions before any updates
            if (!task.style) task.style = {};
            task.style.width = taskCard.style.width || `${taskCard.offsetWidth}px`;
            task.style.height = taskCard.style.height || `${taskCard.offsetHeight}px`;
            
            const escapeHtml = (str) => {
              const div = document.createElement('div');
              div.textContent = str;
              return div.innerHTML;
            };
            
            switch(property) {
              case 'title':
                const titleElement = taskCard.querySelector('.task-title');
                if (titleElement) titleElement.textContent = value;
                break;
              case 'description':
                const descElement = taskCard.querySelector('.task-description');
                if (value) {
                  if (descElement) {
                    descElement.textContent = value;
                  } else {
                    // Create description element if it doesn't exist
                    const taskBody = taskCard.querySelector('.task-body');
                    const newDesc = document.createElement('p');
                    newDesc.className = 'task-description';
                    newDesc.textContent = value;
                    taskBody.insertBefore(newDesc, taskBody.firstChild);
                  }
                } else if (descElement) {
                  descElement.remove();
                }
                break;
              case 'status':
                const statusElement = taskCard.querySelector('.task-status');
                if (statusElement) {
                  statusElement.className = `task-status status-${value}`;
                }
                // Save state for status changes
                this.saveState();
                break;
              case 'dueDate':
                const metaElement = taskCard.querySelector('.task-meta');
                if (metaElement) {
                  const dueDateSpan = metaElement.querySelector('span:first-child');
                  if (value) {
                    const dateText = `Due: ${new Date(value).toLocaleDateString()}`;
                    if (dueDateSpan && dueDateSpan.textContent.startsWith('Due:')) {
                      dueDateSpan.textContent = dateText;
                    } else {
                      const newSpan = document.createElement('span');
                      newSpan.textContent = dateText;
                      metaElement.insertBefore(newSpan, metaElement.firstChild);
                    }
                  } else if (dueDateSpan && dueDateSpan.textContent.startsWith('Due:')) {
                    dueDateSpan.remove();
                  }
                }
                // Save state for date changes
                this.saveState();
                break;
            }
          }
          
          this.updateTaskList();
          
          // Always save to localStorage
          if (property === 'description' || property === 'title') {
            this.debouncedSave();
          } else {
            this.saveToLocalStorage();
          }
        }
      }

      renderSubtasks(task) {
        const container = document.getElementById('subtasksList');
        
        // Escape HTML function
        const escapeHtml = (str) => {
          const div = document.createElement('div');
          div.textContent = str;
          return div.innerHTML;
        };
        
        container.innerHTML = task.subtasks.map((subtask, index) => `
          <div class="subtask ${subtask.completed ? 'completed' : ''}">
            <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
              onchange="taskManager.toggleSubtask('${task.id}', ${index})">
            <input type="text" class="property-input" value="${escapeHtml(subtask.text)}" 
              onchange="taskManager.updateSubtask('${task.id}', ${index}, this.value)"
              style="flex: 1; margin-left: 0.5rem;">
            <button class="task-action" onclick="taskManager.removeSubtask('${task.id}', ${index})">
              <svg class="icon" style="width: 16px; height: 16px;" viewBox="0 0 24 24" fill="none" stroke="currentColor" stroke-width="2">
                <line x1="18" y1="6" x2="6" y2="18"></line>
                <line x1="6" y1="6" x2="18" y2="18"></line>
              </svg>
            </button>
          </div>
        `).join('');
      }

      addSubtask() {
        if (!this.selectedTask) return;
        
        const task = this.projects[this.currentProject].tasks[this.selectedTask];
        if (task) {
          task.subtasks.push({
            text: 'New subtask',
            completed: false
          });
          
          // Update the properties panel
          this.renderSubtasks(task);
          
          // Update only the task card's subtask section
          const taskCard = document.querySelector(`[data-task-id="${this.selectedTask}"]`);
          if (taskCard) {
            // Save current dimensions
            if (!task.style) task.style = {};
            task.style.width = taskCard.style.width || `${taskCard.offsetWidth}px`;
            task.style.height = taskCard.style.height || `${taskCard.offsetHeight}px`;
            
            // Update subtask count
            const metaElement = taskCard.querySelector('.task-meta');
            if (metaElement) {
              let subtaskSpan = Array.from(metaElement.querySelectorAll('span')).find(span => 
                span.textContent.includes('subtasks')
              );
              if (subtaskSpan) {
                subtaskSpan.textContent = `${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks`;
              } else {
                subtaskSpan = document.createElement('span');
                subtaskSpan.textContent = `${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks`;
                metaElement.appendChild(subtaskSpan);
              }
            }
            
            // Update subtasks list
            let subtasksContainer = taskCard.querySelector('.task-subtasks');
            if (!subtasksContainer && task.subtasks.length > 0) {
              subtasksContainer = document.createElement('div');
              subtasksContainer.className = 'task-subtasks';
              taskCard.querySelector('.task-body').appendChild(subtasksContainer);
            }
            
            if (subtasksContainer) {
              const escapeHtml = (str) => {
                const div = document.createElement('div');
                div.textContent = str;
                return div.innerHTML;
              };
              
              subtasksContainer.innerHTML = task.subtasks.map((subtask, index) => `
                <div class="subtask ${subtask.completed ? 'completed' : ''}">
                  <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
                    onchange="taskManager.toggleSubtask('${task.id}', ${index})">
                  <label>${escapeHtml(subtask.text)}</label>
                </div>
              `).join('');
            }
          }
          
          this.saveToLocalStorage();
          // Don't save state for content changes
        }
      }

      toggleSubtask(taskId, index) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (task && task.subtasks[index]) {
          task.subtasks[index].completed = !task.subtasks[index].completed;
          
          // Update only the specific subtask element
          const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
          if (taskCard) {
            const subtaskElements = taskCard.querySelectorAll('.subtask');
            if (subtaskElements[index]) {
              if (task.subtasks[index].completed) {
                subtaskElements[index].classList.add('completed');
              } else {
                subtaskElements[index].classList.remove('completed');
              }
            }
            
            // Update the subtask count in meta
            const metaElement = taskCard.querySelector('.task-meta');
            if (metaElement) {
              const subtaskSpan = Array.from(metaElement.querySelectorAll('span')).find(span => 
                span.textContent.includes('subtasks')
              );
              if (subtaskSpan) {
                subtaskSpan.textContent = `${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks`;
              }
            }
          }
          
          // Update the properties panel if this task is selected
          if (this.selectedTask === taskId) {
            this.renderSubtasks(task);
          }
          
          this.saveToLocalStorage();
          // Don't save state for checkbox toggles
        }
      }

      updateSubtask(taskId, index, text) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (task && task.subtasks[index]) {
          task.subtasks[index].text = text;
          
          // Update the task card display
          const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
          if (taskCard) {
            const subtaskElements = taskCard.querySelectorAll('.subtask label');
            if (subtaskElements[index]) {
              subtaskElements[index].textContent = text;
            }
          }
          
          // Save to localStorage without saving state
          this.debouncedSave();
        }
      }

      removeSubtask(taskId, index) {
        const task = this.projects[this.currentProject].tasks[taskId];
        if (task) {
          task.subtasks.splice(index, 1);
          
          // Update the properties panel
          this.renderSubtasks(task);
          
          // Update only the task card's subtask section
          const taskCard = document.querySelector(`[data-task-id="${taskId}"]`);
          if (taskCard) {
            // Save current dimensions
            if (!task.style) task.style = {};
            task.style.width = taskCard.style.width || `${taskCard.offsetWidth}px`;
            task.style.height = taskCard.style.height || `${taskCard.offsetHeight}px`;
            
            // Update subtask count or remove the span if no subtasks
            const metaElement = taskCard.querySelector('.task-meta');
            if (metaElement) {
              const subtaskSpan = Array.from(metaElement.querySelectorAll('span')).find(span => 
                span.textContent.includes('subtasks')
              );
              if (subtaskSpan) {
                if (task.subtasks.length > 0) {
                  subtaskSpan.textContent = `${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks`;
                } else {
                  subtaskSpan.remove();
                }
              }
            }
            
            // Update or remove subtasks container
            const subtasksContainer = taskCard.querySelector('.task-subtasks');
            if (subtasksContainer) {
              if (task.subtasks.length > 0) {
                const escapeHtml = (str) => {
                  const div = document.createElement('div');
                  div.textContent = str;
                  return div.innerHTML;
                };
                
                subtasksContainer.innerHTML = task.subtasks.map((subtask, idx) => `
                  <div class="subtask ${subtask.completed ? 'completed' : ''}">
                    <input type="checkbox" ${subtask.completed ? 'checked' : ''} 
                      onchange="taskManager.toggleSubtask('${task.id}', ${idx})">
                    <label>${escapeHtml(subtask.text)}</label>
                  </div>
                `).join('');
              } else {
                subtasksContainer.remove();
              }
            }
          }
          
          this.saveToLocalStorage();
          // Don't save state for content changes
        }
      }

      deleteSelectedTask() {
        if (this.selectedTask) {
          this.deleteTask(this.selectedTask);
        }
      }

      deleteTask(taskId) {
        if (confirm('Are you sure you want to delete this task?')) {
          // Remove connections
          this.removeConnections(taskId);
          
          // Remove task
          delete this.projects[this.currentProject].tasks[taskId];
          
          // Update UI
          this.renderTasks();
          this.hideProperties();
          this.selectedTask = null;
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Task deleted');
        }
      }

      duplicateTask(taskId) {
        const originalTask = this.projects[this.currentProject].tasks[taskId];
        if (originalTask) {
          const newTask = {
            ...originalTask,
            id: `task_${++this.taskIdCounter}`,
            title: `${originalTask.title} (Copy)`,
            x: originalTask.x + 50,
            y: originalTask.y + 50,
            subtasks: originalTask.subtasks.map(s => ({...s})),
            style: originalTask.style ? {...originalTask.style} : {
              backgroundColor: '#ffffff',
              borderColor: '#4a90e2',
              width: '250px',
              height: 'auto'
            }
          };
          
          this.projects[this.currentProject].tasks[newTask.id] = newTask;
          
          // Re-render all tasks to ensure proper display
          this.renderTasks();
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Task duplicated');
        }
      }

      createConnection(fromId, toId) {
        const connections = this.projects[this.currentProject].connections;
        
        // Check if connection already exists
        const exists = connections.some(c => 
          (c.from === fromId && c.to === toId) || 
          (c.from === toId && c.to === fromId)
        );
        
        if (!exists) {
          connections.push({ from: fromId, to: toId });
          this.renderConnections();
          this.saveToLocalStorage();
          this.saveState();
          this.showNotification('Tasks connected');
        }
      }

      removeConnections(taskId) {
        const connections = this.projects[this.currentProject].connections;
        this.projects[this.currentProject].connections = connections.filter(c => 
          c.from !== taskId && c.to !== taskId
        );
        this.renderConnections();
        this.saveToLocalStorage();
        this.saveState();
      }

      renderConnections() {
        const svg = document.getElementById('connectionSvg');
        svg.innerHTML = '';
        
        this.projects[this.currentProject].connections.forEach(conn => {
          const fromCard = document.querySelector(`[data-task-id="${conn.from}"]`);
          const toCard = document.querySelector(`[data-task-id="${conn.to}"]`);
          
          if (fromCard && toCard) {
            const fromRect = fromCard.getBoundingClientRect();
            const toRect = toCard.getBoundingClientRect();
            const canvasRect = svg.getBoundingClientRect();
            
            const x1 = fromRect.left + fromRect.width / 2 - canvasRect.left;
            const y1 = fromRect.top + fromRect.height / 2 - canvasRect.top;
            const x2 = toRect.left + toRect.width / 2 - canvasRect.left;
            const y2 = toRect.top + toRect.height / 2 - canvasRect.top;
            
            // Create curved path
            const dx = x2 - x1;
            const dy = y2 - y1;
            const cx = x1 + dx / 2;
            const cy = y1 + dy / 2 - Math.abs(dx) * 0.2;
            
            const path = document.createElementNS('http://www.w3.org/2000/svg', 'path');
            path.setAttribute('d', `M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}`);
            path.setAttribute('class', 'connection-line');
            
            // Add arrow
            const angle = Math.atan2(y2 - cy, x2 - cx);
            const arrowSize = 10;
            const arrow = document.createElementNS('http://www.w3.org/2000/svg', 'polygon');
            arrow.setAttribute('points', `
              ${x2},${y2} 
              ${x2 - arrowSize * Math.cos(angle - Math.PI / 6)},${y2 - arrowSize * Math.sin(angle - Math.PI / 6)} 
              ${x2 - arrowSize * Math.cos(angle + Math.PI / 6)},${y2 - arrowSize * Math.sin(angle + Math.PI / 6)}
            `);
            arrow.setAttribute('class', 'connection-arrow');
            
            svg.appendChild(path);
            svg.appendChild(arrow);
          }
        });
      }

      updateConnections() {
        // Re-render connections when tasks move
        this.renderConnections();
      }

      renderTasks() {
        const canvas = document.getElementById('canvas');
        const canvasArea = document.getElementById('canvasArea');
        
        // Save scroll position
        const scrollLeft = canvasArea.scrollLeft;
        const scrollTop = canvasArea.scrollTop;
        
        // Remove only task cards, not other elements
        const taskCards = canvas.querySelectorAll('.task-card');
        taskCards.forEach(card => card.remove());
        
        Object.values(this.projects[this.currentProject].tasks).forEach(task => {
          this.renderTask(task);
        });
        
        // Only render these if they exist
        if (this.projects[this.currentProject].textBoxes) {
          this.renderTextBoxes();
        }
        if (this.projects[this.currentProject].lines) {
          this.renderLines();
        }
        
        this.renderConnections();
        this.updateTaskList();
        
        // Restore scroll position
        canvasArea.scrollLeft = scrollLeft;
        canvasArea.scrollTop = scrollTop;
        
        // Re-select the previously selected task if it exists
        if (this.selectedTask) {
          const taskCard = document.querySelector(`[data-task-id="${this.selectedTask}"]`);
          if (taskCard) {
            taskCard.classList.add('selected');
          }
        }
      }

      updateTaskList() {
        const taskList = document.getElementById('taskList');
        const tasks = Object.values(this.projects[this.currentProject].tasks);
        
        // Escape HTML function
        const escapeHtml = (str) => {
          const div = document.createElement('div');
          div.textContent = str;
          return div.innerHTML;
        };
        
        taskList.innerHTML = tasks.map(task => `
          <div class="project-item" onclick="taskManager.selectTask('${task.id}')">
            <span class="task-status status-${task.status}"></span>
            <span class="project-name">${escapeHtml(task.title)}</span>
            <span class="project-count">${task.status}</span>
          </div>
        `).join('');
      }

      setTool(tool) {
        this.currentTool = tool;
        this.connectionStart = null;
        this.drawingLine = false;
        this.lineStart = null;
        
        // Update UI
        document.querySelectorAll('.tool-btn').forEach(btn => btn.classList.remove('active'));
        event.target.closest('.tool-btn').classList.add('active');
        
        // Update cursor
        const canvas = document.getElementById('canvas');
        if (tool === 'connect') {
          canvas.style.cursor = 'crosshair';
          this.showNotification('Click to start drawing a line');
        } else if (tool === 'textbox') {
          canvas.style.cursor = 'text';
          this.showNotification('Click where you want to place text');
        } else {
          canvas.style.cursor = 'default';
        }
      }

      updateTaskStyle(property, value) {
        if (!this.selectedTask) return;
        
        const task = this.projects[this.currentProject].tasks[this.selectedTask];
        if (task) {
          if (!task.style) {
            task.style = {
              backgroundColor: '#ffffff',
              borderColor: '#4a90e2',
              width: '250px',
              height: 'auto'
            };
          }
          
          task.style[property] = value;
          
          // Apply style to the element
          const taskCard = document.querySelector(`[data-task-id="${this.selectedTask}"]`);
          if (taskCard) {
            // Preserve current size if changing colors
            if (property === 'backgroundColor' || property === 'borderColor') {
              const currentWidth = taskCard.style.width || `${taskCard.offsetWidth}px`;
              const currentHeight = taskCard.style.height || `${taskCard.offsetHeight}px`;
              
              taskCard.style[property] = value;
              
              // Restore size
              taskCard.style.width = currentWidth;
              taskCard.style.height = currentHeight;
              
              // Save dimensions to task
              task.style.width = currentWidth;
              task.style.height = currentHeight;
            } else {
              taskCard.style[property] = value;
            }
          }
          
          this.saveToLocalStorage();
          // Don't save state for style changes
        }
      }

      zoomIn() {
        this.setZoom(Math.min(this.zoom + 0.1, 2));
      }

      zoomOut() {
        this.setZoom(Math.max(this.zoom - 0.1, 0.3));
      }

      setZoom(newZoom) {
        this.zoom = newZoom;
        const canvas = document.getElementById('canvas');
        canvas.style.transform = `scale(${this.zoom})`;
        canvas.style.transformOrigin = '0 0';
        document.getElementById('zoomLevel').textContent = Math.round(this.zoom * 100) + '%';
        this.updateConnections();
      }

      toggleGrid() {
        this.gridVisible = !this.gridVisible;
        const canvasArea = document.getElementById('canvasArea');
        if (this.gridVisible) {
          canvasArea.style.backgroundImage = 
            'linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px), ' +
            'linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px)';
        } else {
          canvasArea.style.backgroundImage = 'none';
        }
        this.saveToLocalStorage();
      }

      changeBackgroundColor(color) {
        this.backgroundColor = color;
        const canvasArea = document.getElementById('canvasArea');
        canvasArea.style.backgroundColor = color;
        this.saveToLocalStorage();
      }

      promptBackgroundColor() {
        const color = prompt('Enter background color (hex code):', this.backgroundColor);
        if (color) {
          this.changeBackgroundColor(color);
          document.getElementById('bgColorPicker').value = color;
        }
      }

      createProject() {
        const name = prompt('Enter project name:');
        if (name) {
          const projectId = `project_${Date.now()}`;
          this.projects[projectId] = {
            name: name,
            tasks: {},
            textBoxes: {},
            lines: [],
            connections: []
          };
          this.switchProject(projectId);
          this.updateProjectSelector();
          this.saveToLocalStorage();
          this.showNotification('Project created');
        }
      }

      switchProject(projectId) {
        this.currentProject = projectId;
        this.selectedTask = null;
        this.selectedTextBox = null;
        this.selectedLine = null;
        this.renderTasks();
        this.hideProperties();
        this.saveState();
      }

      updateProjectSelector() {
        const selector = document.getElementById('projectSelector');
        selector.innerHTML = Object.entries(this.projects).map(([id, project]) => `
          <option value="${id}" ${id === this.currentProject ? 'selected' : ''}>${project.name}</option>
        `).join('');
      }

      saveState() {
        // Only call this for structural changes like:
        // - Creating/deleting tasks, text boxes, lines, connections
        // - Moving items
        // - Switching projects
        // DO NOT call for content/style updates
        const state = {
          currentProject: this.currentProject,
          projects: JSON.parse(JSON.stringify(this.projects))
        };
        this.undoStack.push(state);
        if (this.undoStack.length > 50) this.undoStack.shift();
        this.redoStack = [];
      }

      undo() {
        if (this.undoStack.length > 1) {
          this.redoStack.push(this.undoStack.pop());
          const state = this.undoStack[this.undoStack.length - 1];
          this.restoreState(state);
          this.showNotification('Undo');
        }
      }

      redo() {
        if (this.redoStack.length > 0) {
          const state = this.redoStack.pop();
          this.undoStack.push(state);
          this.restoreState(state);
          this.showNotification('Redo');
        }
      }

      restoreState(state) {
        this.projects = JSON.parse(JSON.stringify(state.projects));
        this.currentProject = state.currentProject;
        this.renderTasks();
        this.updateProjectSelector();
        this.saveToLocalStorage();
      }

      saveToLocalStorage() {
        const data = {
          projects: this.projects,
          currentProject: this.currentProject,
          taskIdCounter: this.taskIdCounter,
          textBoxIdCounter: this.textBoxIdCounter,
          lineIdCounter: this.lineIdCounter,
          zoom: this.zoom,
          gridVisible: this.gridVisible,
          backgroundColor: this.backgroundColor
        };
        localStorage.setItem('najTaskManager', JSON.stringify(data));
      }

      loadFromLocalStorage() {
        const saved = localStorage.getItem('najTaskManager');
        if (saved) {
          try {
            const data = JSON.parse(saved);
            this.projects = data.projects || this.projects;
            this.currentProject = data.currentProject || this.currentProject;
            this.taskIdCounter = data.taskIdCounter || 0;
            this.textBoxIdCounter = data.textBoxIdCounter || 0;
            this.lineIdCounter = data.lineIdCounter || 0;
            this.zoom = data.zoom || 1;
            this.gridVisible = data.gridVisible !== undefined ? data.gridVisible : true;
            this.backgroundColor = data.backgroundColor || '#f5f7fa';
            
            // Apply saved settings
            this.setZoom(this.zoom);
            this.changeBackgroundColor(this.backgroundColor);
            if (!this.gridVisible) {
              this.toggleGrid();
            }
          } catch (e) {
            console.error('Failed to load saved data:', e);
          }
        }
      }

      clearAll() {
        if (confirm('Are you sure you want to clear all data? This cannot be undone.')) {
          localStorage.removeItem('najTaskManager');
          location.reload();
        }
      }

      exportList() {
        // Create a simple HTML representation for printing as list
        const printWindow = window.open('', '_blank');
        const project = this.projects[this.currentProject];
        const tasks = Object.values(project.tasks);
        
        // Sort tasks by status
        const sortedTasks = tasks.sort((a, b) => {
          const statusOrder = { 'complete': 3, 'progress': 2, 'pending': 1 };
          return statusOrder[a.status] - statusOrder[b.status];
        });
        
        const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>${project.name} - Task List</title>
            <style>
              body { 
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
                padding: 20px;
                line-height: 1.6;
              }
              h1 { 
                color: #2c3e50; 
                border-bottom: 2px solid #3498db;
                padding-bottom: 10px;
              }
              .meta {
                color: #666;
                font-size: 14px;
                margin-bottom: 20px;
              }
              .task { 
                margin-bottom: 25px; 
                padding: 15px; 
                border: 1px solid #ddd; 
                border-radius: 8px;
                page-break-inside: avoid;
              }
              .task-header {
                display: flex;
                justify-content: space-between;
                align-items: center;
                margin-bottom: 10px;
              }
              .task-title { 
                font-weight: bold; 
                font-size: 18px; 
                color: #2c3e50;
              }
              .task-meta { 
                color: #666; 
                font-size: 12px; 
                margin-bottom: 10px; 
              }
              .task-description {
                margin-bottom: 10px;
                color: #444;
              }
              .subtask { 
                margin-left: 20px; 
                padding: 5px 0; 
              }
              .subtask-header {
                font-weight: 600;
                margin-top: 10px;
                margin-bottom: 5px;
              }
              .completed { 
                text-decoration: line-through; 
                color: #999; 
              }
              .status { 
                display: inline-block; 
                padding: 4px 12px; 
                border-radius: 20px; 
                font-size: 12px; 
                font-weight: 600;
                text-transform: uppercase;
              }
              .status-pending { 
                background: #fff3cd; 
                color: #856404; 
              }
              .status-progress { 
                background: #cce5ff; 
                color: #004085; 
              }
              .status-complete { 
                background: #d4edda; 
                color: #155724; 
              }
              .connections {
                margin-top: 10px;
                font-size: 12px;
                color: #666;
              }
              @media print {
                body { padding: 10px; }
                .task { break-inside: avoid; }
              }
            </style>
          </head>
          <body>
            <h1>${project.name} - Task List</h1>
            <div class="meta">
              <strong>Generated:</strong> ${new Date().toLocaleString()}<br>
              <strong>Total Tasks:</strong> ${tasks.length} 
              (${tasks.filter(t => t.status === 'complete').length} completed, 
              ${tasks.filter(t => t.status === 'progress').length} in progress, 
              ${tasks.filter(t => t.status === 'pending').length} pending)
            </div>
            
            ${sortedTasks.map(task => {
              const connections = project.connections.filter(c => c.from === task.id || c.to === task.id);
              const connectedTasks = connections.map(c => {
                const connectedId = c.from === task.id ? c.to : c.from;
                const connectedTask = project.tasks[connectedId];
                return connectedTask ? connectedTask.title : 'Unknown';
              });
              
              return `
              <div class="task">
                <div class="task-header">
                  <div class="task-title">${task.title}</div>
                  <span class="status status-${task.status}">${task.status}</span>
                </div>
                <div class="task-meta">
                  Created: ${new Date(task.createdAt).toLocaleDateString()}
                  ${task.dueDate ? ` | Due: ${new Date(task.dueDate).toLocaleDateString()}` : ''}
                </div>
                <div class="task-description">${task.description}</div>
                ${task.subtasks.length > 0 ? `
                  <div class="subtask-header">Subtasks (${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} completed):</div>
                  ${task.subtasks.map(subtask => `
                    <div class="subtask ${subtask.completed ? 'completed' : ''}">
                      ${subtask.completed ? '☑' : '☐'} ${subtask.text}
                    </div>
                  `).join('')}
                ` : ''}
                ${connectedTasks.length > 0 ? `
                  <div class="connections">
                    <strong>Connected to:</strong> ${connectedTasks.join(', ')}
                  </div>
                ` : ''}
              </div>
            `}).join('')}
          </body>
          </html>
        `;
        
        printWindow.document.write(html);
        printWindow.document.close();
        
        setTimeout(() => {
          printWindow.print();
        }, 250);
        
        this.showNotification('List view ready - use print dialog to save as PDF');
      }

      exportDiagram() {
        // Create a visual representation of the diagram
        const printWindow = window.open('', '_blank');
        const project = this.projects[this.currentProject];
        const tasks = Object.values(project.tasks);
        
        // Find canvas bounds
        let minX = Infinity, minY = Infinity, maxX = -Infinity, maxY = -Infinity;
        tasks.forEach(task => {
          minX = Math.min(minX, task.x);
          minY = Math.min(minY, task.y);
          maxX = Math.max(maxX, task.x + 300); // Approximate width
          maxY = Math.max(maxY, task.y + 200); // Approximate height
        });
        
        const width = Math.max(maxX - minX + 100, 800);
        const height = Math.max(maxY - minY + 100, 600);
        
        const html = `
          <!DOCTYPE html>
          <html>
          <head>
            <title>${project.name} - Task Diagram</title>
            <style>
              @page {
                size: landscape;
                margin: 10mm;
              }
              body { 
                font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Arial, sans-serif; 
                margin: 0;
                padding: 20px;
              }
              h1 { 
                color: #2c3e50; 
                font-size: 24px;
                margin-bottom: 10px;
              }
              .meta {
                color: #666;
                font-size: 12px;
                margin-bottom: 20px;
              }
              .diagram-container {
                position: relative;
                width: ${width}px;
                height: ${height}px;
                border: 1px solid #ddd;
                background: ${this.backgroundColor};
                ${this.gridVisible ? `
                  background-image: 
                    linear-gradient(rgba(0, 0, 0, 0.05) 1px, transparent 1px),
                    linear-gradient(90deg, rgba(0, 0, 0, 0.05) 1px, transparent 1px);
                  background-size: 20px 20px;
                ` : ''}
              }
              .task-box {
                position: absolute;
                background: white;
                border: 2px solid #4a90e2;
                border-radius: 8px;
                box-shadow: 0 2px 4px rgba(0,0,0,0.1);
                min-width: 200px;
                max-width: 300px;
                font-size: 12px;
              }
              .task-header {
                padding: 8px;
                background: #f8f9fa;
                border-bottom: 1px solid #dee2e6;
                border-radius: 6px 6px 0 0;
                font-weight: bold;
              }
              .task-content {
                padding: 8px;
              }
              .task-description {
                color: #666;
                margin-bottom: 5px;
              }
              .task-meta {
                font-size: 10px;
                color: #999;
              }
              .status-indicator {
                display: inline-block;
                width: 8px;
                height: 8px;
                border-radius: 50%;
                margin-right: 5px;
              }
              .status-pending { background: #ffc107; }
              .status-progress { background: #007bff; }
              .status-complete { background: #28a745; }
              svg {
                position: absolute;
                top: 0;
                left: 0;
                width: 100%;
                height: 100%;
                pointer-events: none;
              }
              .connection-line {
                stroke: #4a90e2;
                stroke-width: 2;
                fill: none;
                opacity: 0.6;
              }
              @media print {
                body { padding: 0; }
                h1 { font-size: 18px; }
                .diagram-container { 
                  max-width: 100%; 
                  overflow: visible;
                  page-break-inside: avoid;
                }
              }
            </style>
          </head>
          <body>
            <h1>${project.name}</h1>
            <div class="meta">Generated: ${new Date().toLocaleString()}</div>
            
            <div class="diagram-container">
              <svg>
                ${project.connections.map(conn => {
                  const fromTask = project.tasks[conn.from];
                  const toTask = project.tasks[conn.to];
                  if (!fromTask || !toTask) return '';
                  
                  const x1 = fromTask.x - minX + 125;
                  const y1 = fromTask.y - minY + 50;
                  const x2 = toTask.x - minX + 125;
                  const y2 = toTask.y - minY + 50;
                  
                  const dx = x2 - x1;
                  const dy = y2 - y1;
                  const cx = x1 + dx / 2;
                  const cy = y1 + dy / 2 - Math.abs(dx) * 0.2;
                  
                  return `<path d="M ${x1} ${y1} Q ${cx} ${cy} ${x2} ${y2}" class="connection-line"/>`;
                }).join('')}
              </svg>
              
              ${tasks.map(task => `
                <div class="task-box" style="
                  left: ${task.x - minX}px; 
                  top: ${task.y - minY}px;
                  ${task.style ? `
                    background-color: ${task.style.backgroundColor || '#ffffff'};
                    border-color: ${task.style.borderColor || '#4a90e2'};
                    width: ${task.style.width || '250px'};
                  ` : ''}
                ">
                  <div class="task-header">
                    <span class="status-indicator status-${task.status}"></span>
                    ${task.title}
                  </div>
                  <div class="task-content">
                    <div class="task-description">${task.description}</div>
                    <div class="task-meta">
                      ${task.dueDate ? `Due: ${new Date(task.dueDate).toLocaleDateString()}` : ''}
                      ${task.subtasks.length > 0 ? ` | ${task.subtasks.filter(s => s.completed).length}/${task.subtasks.length} subtasks` : ''}
                    </div>
                  </div>
                </div>
              `).join('')}
            </div>
          </body>
          </html>
        `;
        
        printWindow.document.write(html);
        printWindow.document.close();
        
        setTimeout(() => {
          printWindow.print();
        }, 250);
        
        this.showNotification('Diagram ready - use print dialog to save as PDF');
      }

      showNotification(message) {
        const notification = document.getElementById('notification');
        notification.textContent = message;
        notification.classList.add('show');
        
        setTimeout(() => {
          notification.classList.remove('show');
        }, 3000);
      }

      // Connection methods
      startConnection(fromId) {
        this.connectionStart = fromId;
        this.showNotification('Click on another task to connect');
        
        // Add temporary click handler
        const tempHandler = (e) => {
          const taskCard = e.target.closest('.task-card');
          if (taskCard && taskCard.dataset.taskId !== fromId) {
            this.createConnection(fromId, taskCard.dataset.taskId);
            document.removeEventListener('click', tempHandler);
            this.connectionStart = null;
          }
        };
        
        setTimeout(() => {
          document.addEventListener('click', tempHandler);
        }, 100);
      }
    }

    // Initialize the task manager
    const taskManager = new TaskManager();
  </script>
</body>
</html>
